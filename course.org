* APL by example, an inductive course for the curious mind.

The target audience for this course, is anyone who is fearless.
You will be immediately thrown into Dyalog APL with expressions you can
enter yourself in the Dyalog APL session.
While we walk through several short and sweet example programs, I will hold
your hand along the way - telling you what I think and trying to answer the
questions I would imagine you had, if you where sitting next to me right now,
as I type this.
I expect you to try out partial expressions in your Dyalog APL environment.
For example, when I show you this

#+BEGIN_EXAMPLE
    '*⍟'[1+t⍪⊖t←t,⌽t←n∘.≤n←⍳5]
⍟⍟⍟⍟⍟⍟⍟⍟⍟⍟
*⍟⍟⍟⍟⍟⍟⍟⍟*
**⍟⍟⍟⍟⍟⍟**
***⍟⍟⍟⍟***
****⍟⍟****
****⍟⍟****
***⍟⍟⍟⍟***
**⍟⍟⍟⍟⍟⍟**
*⍟⍟⍟⍟⍟⍟⍟⍟*
⍟⍟⍟⍟⍟⍟⍟⍟⍟⍟
#+END_EXAMPLE

I expect you to try out the different sub-expressions, let's start with 
the innermost! And, one thing I forgot to say before; APL is evaluated
from the right to the left.

#+BEGIN_EXAMPLE
    1+t⍪⊖t←t,⌽t←n∘.≤n←⍳5
2 2 2 2 2 2 2 2 2 2
1 2 2 2 2 2 2 2 2 1
1 1 2 2 2 2 2 2 1 1
1 1 1 2 2 2 2 1 1 1
1 1 1 1 2 2 1 1 1 1
1 1 1 1 2 2 1 1 1 1
1 1 1 2 2 2 2 1 1 1
1 1 2 2 2 2 2 2 1 1
1 2 2 2 2 2 2 2 2 1
2 2 2 2 2 2 2 2 2 2
#+END_EXAMPLE

which seems to be a matrix of 1's and 2's, interesting that we could
index a text array (string) with a matrix!
Next, let's go inwards, removing the 1+ 

#+BEGIN_EXAMPLE
    t⍪⊖t←t,⌽t←n∘.≤n←⍳5
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 0
0 0 1 1 1 1 1 1 0 0
0 0 0 1 1 1 1 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 0 0
0 1 1 1 1 1 1 1 1 0
1 1 1 1 1 1 1 1 1 1
#+END_EXAMPLE

Okay, so we could add 1 to a whole binary matrix, that is cool.
I will expect you to do this kind of fearless jumps of faith 
when you don't really understand an expression.

* The Caesar cipher - implementing and breaking
The Caesar cipher is a simple substitution cipher where the cipher is the result
of rotating the alphabet and re-encoding. The encryption key is the corresponding
rotation necessary. Confused? Don't be! Here are some examples.

#+BEGIN_EXAMPLE
     0 caesar 'abba' 
abba
    
     1 caesar 'abba'
bccb

     2 caesar 'abba'
cddc
#+END_EXAMPLE

** Implementation

The encryption algorithm is quite simple

#+BEGIN_EXAMPLE
  1. Rotate the encoding alfabet N steps : N is the encryption key 
  2. For every character C in the input text
     2.1 Let I be the index of C in the normal alfabet
     2.2 Encode C with the character found at index I 
         from the rotated encoding alfabet
#+END_EXAMPLE

Lets start of with the rotation of the alfabet, first we need an alfabet to work on.
We make this simple and assume that only alphabetic characters can be used. 
Let's define the alfabet, this can be done in two ways, I will show both ways here. 
First we can do it by assigning the whole alfabet in a string.

#+BEGIN_EXAMPLE
      alfabet←'abcdefghijklmnopqrstuvwxyz'
      alfabet
abcdefghijklmnopqrstuvwxyz
#+END_EXAMPLE

the other way is to use the Unicode Convert system function ⎕UCS. It suffices to say
that it can encode the ASCII number to the appropriate alfabetic character. 
Since the alfabet in this case consists of 26 characters, we generate 26 numbers.

#+BEGIN_EXAMPLE
      ⍳26
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
#+END_EXAMPLE

next, we know that lowercase 'a' is on 97, so we shift this sequence by 96.

#+BEGIN_EXAMPLE
      96 + ⍳26
97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122
#+END_EXAMPLE

using ⎕UCS we can now get the full alfabet we want

#+BEGIN_EXAMPLE
      alfabet←⎕UCS 96 + ⍳26
      alfabet
abcdefghijklmnopqrstuvwxyz
#+END_EXAMPLE

Now we want to be able to rotate the alfabet with an encryption key (a number).
This is easily done with the 'circle stile' (rotate) ⌽.

#+BEGIN_EXAMPLE
      rotate←{ ⍵ ⌽ alfabet }
      rotate
 ∇rotate
#+END_EXAMPLE

Now, try invoking the dynamic function (d-fn) rotate which we just defined.

#+BEGIN_EXAMPLE
      rotate 0
abcdefghijklmnopqrstuvwxyz
      rotate 1
bcdefghijklmnopqrstuvwxyza
      rotate 2
cdefghijklmnopqrstuvwxyzab
#+END_EXAMPLE

What remains is to find the index of the letters in the input text.
This is also very simple, thanks to Dyalog APL. 
We use 'iota' ⍳ for this, in 'dyadic' form (two arguments, one to the left
and one to the right). 

#+BEGIN_EXAMPLE
     indices_in_alfabet ←{ alfabet ⍳ ⍵ }
     indices_in_alfabet 'abbacus'
1 2 2 1 3 21 19
#+END_EXAMPLE

Using these indices, we would now like to select letters from the rotated
alfabet. This is actually encoding the message using the encryption key. 

#+BEGIN_EXAMPLE
      caesar ←  { rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alfabet ⍵]}
#+END_EXAMPLE

'diamond' ⋄ is just a newline indicator which used when writing oneliners
in the Dyalog APL environment. The code above is semantically equivalent 
to

#+BEGIN_EXAMPLE
      caesar ←  { rotated←(rotate ⍺),' '
                  rotated[indices_in_alfabet ⍵]
                }
#+END_EXAMPLE

the first line means that we assign the rotated alfabet with the space character
at the end. This because we want to be able to encode spaces as well.
When inquiring for the indices, the space character will not be part of the normal
alfabet, and so a number which is 1 higher than the length of the normal alfabet 
will be returned.

#+BEGIN_EXAMPLE
      alfabet  ⍳ ' a '
27 1 27
#+END_EXAMPLE

thus, adding the space at the end of the rotated alfabet, ensures that we take
care of encoding spaces as well. 
we can now try some examples

#+BEGIN_EXAMPLE
      0 caesar 'attack at dawn when the enemy soldiers are still sleeping'
attack at dawn when the enemy soldiers are still sleeping
      1 caesar 'attack at dawn when the enemy soldiers are still sleeping'
buubdl bu ebxo xifo uif fofnz tpmejfst bsf tujmm tmffqjoh
      2 caesar 'attack at dawn when the enemy soldiers are still sleeping'
cvvcem cv fcyp yjgp vjg gpgoa uqnfkgtu ctg uvknn unggrkpi
#+END_EXAMPLE

So, how do we decipher a caesar cipher if we know the key?
Simple, we just apply the negative rotation.

#+BEGIN_EXAMPLE
      clear_text←'attack at dawn when the enemy soldiers are still sleeping'
      key←12
      cipher← key caesar clear_text
      cipher
mffmow mf pmiz itqz ftq qzqyk eaxpuqde mdq efuxx exqqbuzs
      (¯1×key) caesar cipher
attack at dawn when the enemy soldiers are still sleeping
#+END_EXAMPLE

** Breaking the caesar cipher with a lookup attack

The caesar ciphers we can produce now are vulnerable to brute force
attacks, where the attacker will try all 26 possible counter rotations 
and looking up results in a dictionary. The lookup attack algorithm is quite simple.

#+BEGIN_EXAMPLE
 1. Try all 26 possible counter-rotations
 2. For every counter-rotation R_i
    2.1 check how many words from the possibly decrypted text can be
        found in a dictionary, this is the score S_i of R_i.
 3. The counter-rotation R_i with the highest score S_i is the most
    probable key.       
#+END_EXAMPLE

Let's try doing this ourselves! We start by generating a random key between 1 and 26, 
we use the roll '?' operator for this.

#+BEGIN_EXAMPLE
      clear_text←'attack at dawn when the enemy soldiers are still sleeping'
      key ← ? 26
      cipher  ←  key caesar clear_text
      cipher
dwwdfn dw gdzq zkhq wkh hqhpb vroglhuv duh vwloo vohhslqj
#+END_EXAMPLE

Now, let's try 26 possible counter-rotations, this is done by generating
all numbers from ¯26 to ¯1.

#+BEGIN_EXAMPLE
      (¯1 × ⍳ 26)
¯1 ¯2 ¯3 ¯4 ¯5 ¯6 ¯7 ¯8 ¯9 ¯10 ¯11 ¯12 ¯13 ¯14 ¯15 ¯16 ¯17 ¯18 ¯19 ¯20 ¯21 ¯22 ¯23 ¯24 ¯25 ¯26
#+END_EXAMPLE

what we want to do now, is to use the caesar cipher with each and every key,
on the cipher text. For this, we will do what is called 'outer product' with the
caesar d-fn (∘.caesar). This is just distributing the left arguments over the function 
and the right argument.

#+BEGIN_EXAMPLE
      (¯1 × ⍳ 26) ∘.caesar ⊂cipher
 ....this is a lot of text
#+END_EXAMPLE

We had to 'enclose' ⊂ the right argument to turn it into a scalar for the outer product
to work properly, this is a detail that will be covered more thoroughly later.
We can make this more readable by creating a rectangular matrix of the result.
Because we get an array of 26 elements (one caesar-application for every negative key),
and every element is as long as the cipher text, we can build a 26 by 57 matrix,
using 'mix' ↑. Let's check that the mental calculation is correct by asking for the dimensions 
of the result, using 'shape' ⍴.

#+BEGIN_EXAMPLE
      ⍴ ↑ (¯1 × ⍳ 26) ∘.caesar ⊂cipher
26 57
#+END_EXAMPLE

Yep, 26 rows and 57 columns.

#+BEGIN_EXAMPLE
      ↑ (¯1 × ⍳ 26) ∘.caesar ⊂cipher
cvvcem cv fcyp yjgp vjg gpgoa uqnfkgtu ctg uvknn unggrkpi
buubdl bu ebxo xifo uif fofnz tpmejfst bsf tujmm tmffqjoh
attack at dawn when the enemy soldiers are still sleeping
zsszbj zs czvm vgdm sgd dmdlx rnkchdqr zqd rshkk rkddohmf
yrryai yr byul ufcl rfc clckw qmjbgcpq ypc qrgjj qjccngle
xqqxzh xq axtk tebk qeb bkbjv pliafbop xob pqfii pibbmfkd
wppwyg wp zwsj sdaj pda ajaiu okhzeano wna opehh ohaalejc
voovxf vo yvri rczi ocz zizht njgydzmn vmz nodgg ngzzkdib
unnuwe un xuqh qbyh nby yhygs mifxcylm uly mncff mfyyjcha
tmmtvd tm wtpg paxg max xgxfr lhewbxkl tkx lmbee lexxibgz
sllsuc sl vsof ozwf lzw wfweq kgdvawjk sjw kladd kdwwhafy
rkkrtb rk urne nyve kyv vevdp jfcuzvij riv jkzcc jcvvgzex
qjjqsa qj tqmd mxud jxu uduco iebtyuhi qhu ijybb ibuufydw
piiprz pi splc lwtc iwt tctbn hdasxtgh pgt hixaa hattexcv
ohhoqy oh rokb kvsb hvs sbsam gczrwsfg ofs ghwzz gzssdwbu
nggnpx ng qnja jura gur rarzl fbyqvref ner fgvyy fyrrcvat
mffmow mf pmiz itqz ftq qzqyk eaxpuqde mdq efuxx exqqbuzs
leelnv le olhy hspy esp pypxj dzwotpcd lcp detww dwppatyr
kddkmu kd nkgx grox dro oxowi cyvnsobc kbo cdsvv cvoozsxq
jccjlt jc mjfw fqnw cqn nwnvh bxumrnab jan bcruu bunnyrwp
ibbiks ib liev epmv bpm mvmug awtlqmza izm abqtt atmmxqvo
haahjr ha khdu dolu aol lultf zvskplyz hyl zapss zsllwpun
gzzgiq gz jgct cnkt znk ktkse yurjokxy gxk yzorr yrkkvotm
fyyfhp fy ifbs bmjs ymj jsjrd xtqinjwx fwj xynqq xqjjunsl
exxego ex hear alir xli iriqc wsphmivw evi wxmpp wpiitmrk
dwwdfn dw gdzq zkhq wkh hqhpb vroglhuv duh vwloo vohhslqj
#+END_EXAMPLE

visual inspection shows that the third row from the top is very readable, 
this would put the randomized key to be 3.
Let's check.

#+BEGIN_EXAMPLE
      key
3
#+END_EXAMPLE

But what if we want this to be totally automated? If we have many (thousands!) ciphers, 
we would like the computer to do this for us and avoid having to do visual inspection.
This is where the lookup part of the attack comes into play.
Lets start by declaring the dictionary 

#+BEGIN_EXAMPLE
      dictionary ← 'soldier' 'attack' 'dawn' 'swords' 'blood'
#+END_EXAMPLE

The dictionary is now an array with 5 elements, each one being a text-array.
We can once again use 'shape' ⍴ to verify this, or 'tally' ≢.

#+BEGIN_EXAMPLE
     ⍴ dictionary
5
     ≢ dictionary
5
#+END_EXAMPLE

Let's now define the lookup function that takes a piece of text, splits it into 
words and tries to see how many of these words exist in the dictionary.
First, we need to learn how to split a string into several small strings.
We can partition an array according to the pattern of a binary mask by using
'partition' ⊂ from what is called ML 3. An example is in order

#+BEGIN_EXAMPLE
     ⎕ML←3
     text  ← 'this is a piece of text with spaces'
     ' '≠text
1 1 1 1 0 1 1 0 1 0 1 1 1 1 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 1 1
     (' '≠text)⊂text
 this  is  a  piece  of  text  with  spaces
     ⍴ (' '≠text)⊂text
8
    ⎕ML←1
#+END_EXAMPLE

Do NOT forget to execute the last statement ⎕ML←1, it could have interesing
consequences! So, let's partition and search for hits! We will do this step-wise to introduce
the necessary concepts. First we want to split the string into substrings.
We have seen how to do this in ⎕ML ← 3 (quad ML three).

#+BEGIN_EXAMPLE
   ⎕ML  ← 3
   text ← 'attack at dawn when the enemy soldiers are still sleeping'
   words ← (' ' ≠text)⊂text   
   ⎕ML ← 1
#+END_EXAMPLE

We now want to know many of the words exist in the dictionary. This is done
by means of outer product with 'match' ≡. This will produce a 10 by 5 matrix.

#+BEGIN_EXAMPLE
     words ∘.≡ dictionary
0 1 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
#+END_EXAMPLE

Every row of the matrix is one particular word in words, every column is one
particular entry in the dictionary. The matrix element e_ij is the indications if the
i:th word matched the j:th entry in the dictionary. To calculate the total 
match-score of this text, we 'plus reduce' +/ the matrix two times.
First time we are collapsing it along the first dimension (columns), this yields
an array of length 10.

#+BEGIN_EXAMPLE
      +/ words ∘.≡ dictionary
1 0 1 0 0 0 0 0 0 0
      ⍴ +/ words ∘.≡ dictionary
10
#+END_EXAMPLE

Next we reduce it again, this time we get a scalar result.

#+BEGIN_EXAMPLE
      +/ +/ words ∘.≡ dictionary
2
      ⍴ +/ +/ words ∘.≡ dictionary
#+END_EXAMPLE

We can see that this is a scalar result since 'shape' reports an empty result.
This means that there is no dimension on the argument to 'shape' ⍴. Scalars are
dimension-less in APL.

We now have the recipe for the score calculation, and we can define our d-fn.

#+BEGIN_EXAMPLE
      score ← { ⎕ML←3 ⋄ words←(' '≠⍵)⊂⍵ ⋄ +/+/words∘.≡dictionary}
#+END_EXAMPLE

Remember that this is semantically equivalent to the following multi-line definition.

#+BEGIN_EXAMPLE
      score ← { ⎕ML←3
                words←(' '≠⍵)⊂⍵
                +/+/words∘.≡dictionary
              }
#+END_EXAMPLE

and we test it with our decrypted text.

#+BEGIN_EXAMPLE
      score 'attack  at  dawn  when  the  enemy  soldiers  are  still  sleeping'
2
#+END_EXAMPLE

we have the rotations, and we have the scores, now we need to apply the rotations,
and calculate the scores, selecting the rotation with highest score.
With Dyalog APL - this is simple. Once again, let's do this stepwise in the Dyalog APL 
environment, and once we have 'found the recipe' we put it into a d-fn.

#+BEGIN_EXAMPLE
      rotations ← ¯1×⍳26
      scores ← score ¨ rotations ∘.caesar ⊂cipher
#+END_EXAMPLE
 
now we want to know which score is the highest ranked one, this can be done by aquiring
the descending order of indices as they can be used to retrieve the sorted result 
from an array. The function is called 'grade down' ⍒.
And once again, an example is in order.

#+BEGIN_EXAMPLE
      ⍒ 3 1 4 6 2
4 3 1 5 2
#+END_EXAMPLE

so, what we want is to 'grade down' the scores and take the first index in the array.

#+BEGIN_EXAMPLE
      ⍒ scores
3 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
#+END_EXAMPLE

we can take the first by using 'take' ↑.

#+BEGIN_EXAMPLE
      1 ↑ ⍒ scores
3
#+END_EXAMPLE

And to finalize this, we should negate the result.

#+BEGIN_EXAMPLE
      rotations ← ¯1×⍳26
      scores ← score ¨ rotations ∘.caesar ⊂cipher
      ¯1 × 1 ↑ ⍒ scores
#+END_EXAMPLE

therefore, our function break can now be defined

#+BEGIN_EXAMPLE
      break ← {rs ← ¯1×⍳26 ⋄ ss ← score ¨ rs∘.caesar ⊂⍵ ⋄ ¯1×1↑⍒ss }
#+END_EXAMPLE

and we can test it immediately with a new randomized cipher

#+BEGIN_EXAMPLE
      text ← 'the attack failed at dawn'
      key←?26
      cipher←key caesar text
      cipher
nby unnuwe zucfyx un xuqh
      break cipher
¯20
      ¯20 caesar cipher
the attack failed at dawn
#+END_EXAMPLE

the full listing of the functions we have defined can be seen by listing
the functions in the current workspace.

#+BEGIN_EXAMPLE
      )fns
break   caesar  indices_in_alfabet      rotate  score
#+END_EXAMPLE

we can now use 'vector representation' to display the definition of every 
function.

#+BEGIN_EXAMPLE
      ⎕vr ¨ 'break' 'caesar' 'score' 'rotate' 'indices_in_alfabet'
      ∇ break←{rs←¯1×⍳26 ⋄ ss←score¨rs∘.caesar⊂⍵ ⋄ ¯1×1↑⍒ss}
      ∇ caesar←{rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alfabet ⍵]}
      ∇ score←{⎕ML←3 ⋄ words←(' '≠⍵)⊂⍵ ⋄ +/+/words∘.≡dictionary}
      ∇ rotate←{⍵⌽alfabet}
      ∇ indices_in_alfabet←{alfabet⍳⍵}
#+END_EXAMPLE





** Breaking the securer caesar cipher

There is one thing that can be done to make the caesar cipher slightly trickier
to break. If we remove all spaces so that word boundaries become anonymous, we will
not be able to break the 26 rotations into substrings and look them up in the dictionary,
but we would be able to do the reverse; find matching substrings in the 26 rotations
with the dictionary words. An alternate and more interesting approach, would be
to measure the letter frequency, and see if it aligns with the letter frequency of
proper english.
Instead of passing 'hello world how are you' to the encryption algorithm, we will pass
an equivalent of 'helloworldhowareyou'. The algorithm for breaking the slightly harder to break
caesar cipher is thus

#+BEGIN_EXAMPLE
 1. Try all 26 possible counter-rotations
 2. For every counter-rotation R_i
    2.1 F_i is the measured letter frequency of the resulting text.
        Calculate the distance D_i between english letter frequency and F_i
 3. The counter-rotation R_i with the lowest distance D_i is the most
    probable key.
#+END_EXAMPLE

Lets start by creating our cleartext.

#+BEGIN_EXAMPLE
   text ← ⊂'thefirstincarnationofwhatwaslatertobetheaplprogramminglanguagewaspublishedand'
   text,← ⊂'formalizedinaprogramminglanguageabookdescribinganotationinventedbykennetheiverson'
   text,← ⊂'whileatharvarduniversityiversonhaddevelopedamathematicalnotationformanipulating'
   text,← ⊂'arraysthathetaughttohisstudentsiversondescribedthepremiseofthebookinthepreface'
   text,← ⊂'appliedmathematicsislargelyconcernedwiththedesignandanalysisofexplicitprocedures'
   text,← ⊂'forcalculatingtheexactorapproximatevaluesofvariousfunctionssuchexplicitprocedures'
#+END_EXAMPLE

This should be enough. Notice that we perform 6 element assignments into the array text
which now holds 6 texts. The first assignment asigns an enclosed array (thus becoming a scalar)
to text. The second assignment is a special, called 'modified assignment' ,←.
text now holds six elements, each element being an array, we can verify this by looking
at the shape and 'depth' ≡ of text.

#+BEGIN_EXAMPLE
      ⍴ text
6
      ≡ text
2
#+END_EXAMPLE

we can now count the length of each string in text, by utilizing 'each' ¨ and shape.

#+BEGIN_EXAMPLE
      ⍴ ¨ text
 77  81  79  78  80  81
#+END_EXAMPLE

this means, that if we concatenate all strings in text, we should end up with one 
single string of length 476. In order to concatenate all the strings, we utilize
'comma-reduce' ,/ which reduces along the first dimension with comma; comma is catenation.

#+BEGIN_EXAMPLE
      ,/ text
 thefirstincarnatio.....(a lot of text)
      ⍴ ⊃ ,/ text
476
#+END_EXAMPLE

You noticed that I 'disclosed' ⊃ the result from ,/ before applying shape.
This is because all reductions with the operator / and some function produce a scalar result.
But we wish to work on the actual array, therefore we disclose it.

What we need now, is a d-fn for measuring letter frequency in a text.
For each letter in the alphabet, we wish to count the amount of times it occurrs in 
a text, and then divide this by the length of the text.
We utilize the outer product once again, with the alfabet; in the example below,
we do the following: for each of the 26 letters in the alfabet, perform array
comparison with the given text to the left, letter by letter inside it.
I produce a binary 26 by 30 matrix from this result with 'mix' ↑.

#+BEGIN_EXAMPLE
      ↑ alfabet ∘.= ⊂'abbacuswasatoolforcalculations'
1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#+END_EXAMPLE

what remains now, is to sum the 1's for each row, this is plus-reduce again.

#+BEGIN_EXAMPLE
      +/ ↑ alfabet ∘.= ⊂'abbacuswasatoolforcalculations'
6 2 3 0 0 1 0 0 1 0 0 3 0 1 4 0 0 1 3 2 2 0 1 0 0 0
#+END_EXAMPLE

we can now see that there are 6 a's in the text, 2 b's etc. We now need to divide
by the length of the text in question.

#+BEGIN_EXAMPLE
     (+/ ↑ alfabet ∘.= ⊂'abbacuswasatoolforcalculations')÷⍴'abbacuswasatoolforcalcula
0.2 0.06666666667 0.1 0 0 0.03333333333 0 0 0.03333333333 0 0 0.1 0 0.03333333333......
#+END_EXAMPLE

We can now put this into a dynamic function (d-fn) and amaze at the conciseness.

#+BEGIN_EXAMPLE
      frequency ← { (+/↑alfabet∘.=⊂⍵)÷⍴⍵ }
      frequency ⊃,/ text
0.1029411765 0.01470588235 0.03571428571 ......
#+END_EXAMPLE

Next up, we need to compare how close a measured letter frequency is to the english 
letter frequency, for that we need the english letter frequency (which I happen to have added).

#+BEGIN_EXAMPLE
      english
0.08167 0.01492 0.02782 0.04253 0.12702 0.02228 0.02015 0.06094 0.06966 0.00153 0.00772 0.04025 0.02406 0.06749 0.07507 0.01929 0.00095 0.05987 0.06327 0.09056 0.02758 0.00978 0.0236 0.0015 0.01974 0.00074
#+END_EXAMPLE

Now we can write the d-fn for performing the calculation of euclidean distance between two vectors.
This is no more than the square root of the sum of the squares of distances.

#+BEGIN_EXAMPLE
      distance ← { sqd←(⍺-⍵)*2 ⋄ sum←+/sqd ⋄ sum*0.5 }
#+END_EXAMPLE

Notice how the d-fn for distance has ⍺ and ⍵. This is because distance is dyadic, it will take a left
argument and a right argument. ⍺ is the left argument, and ⍵ is the right argument.
We can test it out with multiple vectors. Actually, let's calculate the euclidean distance to all discrete
carthesian products in the range (1 1) to (10 10). We can easily produce all such pairs with monadic iota ⍳. 

#+BEGIN_EXAMPLE
      ⍳ 10 10
 1 1   1 2   1 3   1 4   1 5   1 6   1 7   1 8   1 9   1 10
 2 1   2 2   2 3   2 4   2 5   2 6   2 7   2 8   2 9   2 10
 3 1   3 2   3 3   3 4   3 5   3 6   3 7   3 8   3 9   3 10
 4 1   4 2   4 3   4 4   4 5   4 6   4 7   4 8   4 9   4 10
 5 1   5 2   5 3   5 4   5 5   5 6   5 7   5 8   5 9   5 10
 6 1   6 2   6 3   6 4   6 5   6 6   6 7   6 8   6 9   6 10
 7 1   7 2   7 3   7 4   7 5   7 6   7 7   7 8   7 9   7 10
 8 1   8 2   8 3   8 4   8 5   8 6   8 7   8 8   8 9   8 10
 9 1   9 2   9 3   9 4   9 5   9 6   9 7   9 8   9 9   9 10
 10 1  10 2  10 3  10 4  10 5  10 6  10 7  10 8  10 9  10 10
#+END_EXAMPLE

let us now perform outer product with distance to 1 1.

#+BEGIN_EXAMPLE
      (⍳ (10 10)) ∘.distance ⊂(1 1)
0 1           2           3           4            5            6            7            8            9
1 1.414213562 2.236067977 3.16227766  4.123105626  5.099019514  6.08276253   7.071067812  8.062257748  9.055385138
2 2.236067977 2.828427125 3.605551275 4.472135955  5.385164807  6.32455532   7.280109889  8.246211251  9.219544457
3 3.16227766  3.605551275 4.242640687 5            5.830951895  6.708203932  7.615773106  8.544003745  9.486832981
4 4.123105626 4.472135955 5           5.656854249  6.403124237  7.211102551  8.062257748  8.94427191   9.848857802
5 5.099019514 5.385164807 5.830951895 6.403124237  7.071067812  7.810249676  8.602325267  9.433981132 10.29563014
6 6.08276253  6.32455532  6.708203932 7.211102551  7.810249676  8.485281374  9.219544457 10           10.81665383
7 7.071067812 7.280109889 7.615773106 8.062257748  8.602325267  9.219544457  9.899494937 10.63014581  11.40175425
8 8.062257748 8.246211251 8.544003745 8.94427191   9.433981132 10           10.63014581  11.3137085   12.04159458
9 9.055385138 9.219544457 9.486832981 9.848857802 10.29563014  10.81665383  11.40175425  12.04159458  12.72792206
#+END_EXAMPLE

The last thing we need to do now, is to combine all of this, just like we did for the lookup attack.
But, let's generate a random key and produce a cipher from the concatenated text.

#+BEGIN_EXAMPLE
      key←?26
      cipher←key caesar ⊃,/text
      cipher
kyvwzijkzetrie.....(a lot of text)
#+END_EXAMPLE

notice how the old break d-fn will not work on this.

#+BEGIN_EXAMPLE
      break cipher
¯1
#+END_EXAMPLE

Now, the grande finale.

#+BEGIN_EXAMPLE
      rotations←¯1×⍳26
      distances ← english∘distance ¨ frequency ¨ rotations ∘.caesar ⊂cipher
      ¯1 × 1↑⍋distances
¯17
      ¯17 caesar cipher
thefirstincarnationofwhatwaslatertobetheapl...(lots of text)
#+END_EXAMPLE

The difference to the prior algorithm is that we have frequency on 'each' ¨ result, and 
use 'grade-up' ⍋ to get the indices in an ascending order.
Clearly, ¯17 is the counter-rotation, thus the original text was encrypted with 17 as the key.
The finalizing d-fn now follows.

#+BEGIN_EXAMPLE
      freq_break←{ rs←¯1×⍳26 ⋄ ds ← english∘distance ¨ frequency ¨ rs ∘.caesar ⊂⍵ ⋄ ¯1×1↑⍋ds }
      freq_break cipher
¯17
      ¯17 caesar cipher
thefirstincarnationofwhatwaslatertobetheapl....(lots of text)
#+END_EXAMPLE

The full listing for this frequency breaking are shown below.

#+BEGIN_EXAMPLE
⎕vr ¨ 'freq_break' 'distance' 'frequency' 'caesar' 'rotate' 'indices_in_alfabet'
∇ freq_break←{rs←¯1×⍳26 ⋄ ds←english∘distance¨frequency¨rs∘.caesar⊂⍵ ⋄ ¯1×1↑⍋ds}
∇ distance←{sqd←(⍺-⍵)*2 ⋄ sum←+/sqd ⋄ sum*0.5}
∇ frequency←{(+/↑alfabet∘.=⊂⍵)÷⍴⍵}
∇ caesar←{rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alfabet ⍵]}
∇ rotate←{⍵⌽alfabet}
∇ indices_in_alfabet←{alfabet⍳⍵}
#+END_EXAMPLE

** Saving the work of the day

Now that I have something interesting, I would like to save it for future reference.
Also, I would be upset if the computer crashed and all the work was lost.
We can save the work by saving the workspace, I chose to save it was warmup

#+BEGIN_EXAMPLE
      )save warmup
warmup saved Wed Apr  9 20:37:47 2014
#+END_EXAMPLE

I can now clear the workspace and see that it is really clear by listing functions
and variables

#+BEGIN_EXAMPLE
      )clear
clear ws
      )fns
      )vars
#+END_EXAMPLE

Let us load the warmup namespace again

#+BEGIN_EXAMPLE
      )load warmup
./warmup saved Wed Apr  9 20:37:47 2014
      )fns
break   caesar       distance  freq_break      frequency
indices_in_alfabet   rotate    score
      )vars
alfabet    cipher   clear_text  dictionary
distances  english  key         rotations       scores
#+END_EXAMPLE

I noticed that I have some lingering variables I wish not to have, so I will
expunge them from the workspace (here I apply ⎕ex to each name with ¨)

#+BEGIN_EXAMPLE
      ⎕ex ¨ 'key' 'rotations' 'scores' 'distances'
#+END_EXAMPLE

But what if we forget the name of our workspace?
Then we list all workspaces with )lib, this is what I get on my Linux.

#+BEGIN_EXAMPLE
      )lib
.
        warmup
/opt/mdyalog/14.0/64/unicode/ws
      apl2in   apl2pcin conga   display dwsin   dwsout   fonts   ftp   groups  newleaf ops
      postscri quadna   rainpro salt    smdemo  smdesign smtutor sqapl tutor   util
      xfrcode  xlate
/opt/mdyalog/14.0/64/unicode/samples/dfns
      ddb     dfns    eval    max     min     tube
/opt/mdyalog/14.0/64/unicode/samples/tcpip
      chat    echo    qfiles  rexec   www
/opt/mdyalog/14.0/64/unicode/samples/OO4APL
      Chapter9.DWS       ComponentFile.DWS   ExcelWorkBook.DWS  Monthly.DWS
      MonthlyAfter5.DWS  OOTools.DWS         PlanBook.DWS       PlanBookFinal.DWS  Queue.DWS
      Random.DWS         TimeSeries.DWS      derivedgui.DWS     dotnet.DWS         guitools.DWS
#+END_EXAMPLE

So, what does the workspace look like outside of the Dyalog APL environment?
It is a binary which will not be possible to interpret outside of the Dyalog APL
environment. Let's exit the Dyalog APL environment and look at it with some standard 
linux tools (strings, file and hexdump).

#+BEGIN_EXAMPLE
   ⎕OFF
$> file warmup
warmup: Dyalog APL workspace type 14 subtype 1 64-bit unicode little-endian
$> strings warmup
Dyalog
ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789
....
soldier
attack
dawn
swords
blood
ERCP
@$q8D
attack
dawn
when
enemy
soldiers
still
sleeping
...
$> head -n 2 warmup | hexdump -C
00000000  aa 03 0e 01 0e 00 fd a4  00 02 00 00 00 00 00 00  |................|
00000010  60 ea ff ff ff ff ff ff  71 00 00 00 00 00 00 00  |`.......q.......|
00000020  c0 36 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.6..............|
00000030  07 73 70 00 00 00 00 00  00 00 00 00 00 00 00 00  |.sp.............|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  80 3b 84 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |.;.9............|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000090  77 41 84 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |wA.9............|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000c0  4b 63 9b 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |Kc.9............|
000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000f0  9c 5d 9b 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |.].9............|
00000100  00 00 00 00 00 00 00 00  50 f5 f7 ff ff ff ff ff  |........P.......|
00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000130  00 00 00 00 00 00 00 00  58 5b 00 00 00 00 00 00  |........X[......|
00000140  48 0a 00 00 00 00 00 00  68 0a                    |H.......h.|
0000014a
#+END_EXAMPLE

Clearly, it will be VERY difficult to put this under version control.
And this is why we will work with SALT scripts from now on.
SALT scripts are Dyalog APL files which can be read from outside the Dyalog APL
environment, just like normal source files from any other language.

* A Tiny Booking DSL 
** SALT booking namespace
A Domain Specific Language (DSL) is a language specific to a domain.
We can design our own Booking DSL easily in Dyalog APL, creating a 
set of instructions which feel natural for the users of the system.

As I mentioned in the previous chapter, we will now use Dyalog APL SALT
scripts, so we can read them from outside of the Dyalog APL environment.
Let's start by creating our first SALT script.
Use your favourite editor and create the file booking.dyalog, inside we 
put the following empty namespace.

#+BEGIN_EXAMPLE
:NameSpace booking

:EndNameSpace
#+END_EXAMPLE

we can now load this SALT script in the Dyalog APL environment using
⎕SE.SALT.Load (I assign the result to ⎕ in order to show the shy result).

#+BEGIN_EXAMPLE
      ⎕←⎕SE.SALT.Load './booking.dyalog'
#.booking
#+END_EXAMPLE

The #.booking result indicates that the root namespace # now has a namespace
inside of it, called booking, accessible through #.booking. We can list all
namespaces with ⎕NL 9

#+BEGIN_EXAMPLE
      ⎕NL 9
booking
#+END_EXAMPLE

** Creating the database
We can now add a function to initialize the room database with 4 bookable
rooms, each room has 8 bookable hours, and 5 days a week. We do this by
typing #.booking C-e (control-e). This will open an editor window, allowing
us to enter a function into the booking namespace.
But, we will close this window (escape) and experiment a bit more in the 
Dyalog APL repl.

#+BEGIN_EXAMPLE
Dyalog APL/S-64 Version 14.0.19453          ┌booking──────────────────────────────────┐
Unicode Edition                             │    :NameSpace booking                   │
Thu Apr 10 20:04:26 2014                    │                                         │
clear ws                                    │    :EndNameSpace                        │
                                            │                                         │
      ⎕←⎕SE.SALT.Load './booking.dyalog'    │                                         │
#.booking                                   │                                         │
      ⎕NL 9                                 │                                         │
booking                                     │                                         │
      #.booking                             │                                         │
                                            └⍟────────────────────────────────────────┘

#+END_EXAMPLE

But, we will close this window (escape) and experiment a bit more in the 
Dyalog APL repl. Let's start by creating a 4 (rooms) by 8 (hours) matrix
of all zeroes using reshape ⍴ in dyadic form.

#+BEGIN_EXAMPLE
    4 8 ⍴ 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

Every row represents a room and every column represents an hour, a 0 means
the room is free, a number indicates it's booked by someone with an id equal
to the number. Now, let's make a cube out of this, so we have 5 days.

#+BEGIN_EXAMPLE
   5 4 8 ⍴ 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

every matrix is one day, and the same rules apply for each such matrix as for 
the 4 8 ⍴ 0 case. This seems good enough, let us now open the #.booking
namespace by pressing C-e (control-e) on #.booking in the Dyalog environment.

#+BEGIN_EXAMPLE
:NameSpace booking

[0]       init_db  ← { #.db ← 5 4 8 ⍴ 0 }

:EndNameSpace
#+END_EXAMPLE

Remember to exit the editor by pressing escape.
When we press escape, Dyalog SALT will ask if we want to update the source
file for "#.booking", I press y for YES.

#+BEGIN_EXAMPLE
 Update source file for "#.booking"?

 If you choose YES, file </home/gianfranco/APL_course/booking.dyalog> will be overwritten.

 If you choose NO, the changes won't be filed
 Y/N? Y
#+END_EXAMPLE

We can now check that the file has been updated outside of the Dyalog APL environment
by opening it with our favourite editor, or just doing less on it.

#+BEGIN_EXAMPLE
> less booking.dyalog
:NameSpace booking

    init_db←{#.db←5 4 8 ⍴ 0}

:EndNameSpace
#+END_EXAMPLE

We have now assigned the dynamic function to init_db in #.booking.
We can check that the d-fn has been defined by listing the available functions
in the #.booking namespace using ⎕NL 3 from within the #.booking namespace

#+BEGIN_EXAMPLE
     #.booking.⎕NL 3
init_db
#+END_EXAMPLE

we can also visualize the function using ⎕vr (vector representation) 

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.init_db'
     ∇ init_db←{#.db←5 4 8⍴0}
     ∇
#+END_EXAMPLE

if we now run the init_db function, a db will be created in the root 
namespace. 

#+BEGIN_EXAMPLE
      )vars
      #.booking.init_db ⍬
      )vars
db
      db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

Notice how the d-fn has to be invoked with a zilde ⍬ (empty) argument.
if we don't do that, the evaluation will just return the d-fn itself.

#+BEGIN_EXAMPLE
      #.booking.init_db
{#.db←5 4 8⍴0}
#+END_EXAMPLE

** Booking a room
What if we could type the following and actually get what we expect?

#+BEGIN_EXAMPLE
      book first free on friday for 3 from 2
#+END_EXAMPLE

In case you don't really follow the intention of the above, it means
to book the first freely available room on friday for 3 hours if 
possible from the second hour and onwards.

Let's start with the rightmost (as APL is interpreted from right to left).
The 'from' function. It would be nice if this returns an array of hours
which are in the range, thus for this example

#+BEGIN_EXAMPLE
      from 2 
2 3 4 5 6 7 8
#+END_EXAMPLE

Let's start by creating all numbers up to 8, and then dropping the first
x-1.

#+BEGIN_EXAMPLE
      ⍳8
1 2 3 4 5 6 7 8
      1↓⍳8
2 3 4 5 6 7 8
#+END_EXAMPLE

we now put this into from in the #.booking namespace in the same way as before
#.booking (C-e) edit and esc, Y. We can list the source code of from with ⎕vr.

#+BEGIN_EXAMPLE
      ⎕vr '#.booking.from'
     ∇ from←{(¯1+⍵)↓⍳8}
     ∇
#+END_EXAMPLE

Next, lets write the 'for' function. It would seem appropriate for this function
to take 3 of the hours it was given as the second argument (the hours we get in from).
This is really no more than just a normal take ↑, the only thing making it interesting
for us is that we get two arguments on the right of 'for' and we need to take as many
elements from the second input argument =⍵[2]= as the first argument =⍵[1]=.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.for'
     ∇ for←{⍵[1]↑⍵[2]}
     ∇
#+END_EXAMPLE

Let us now try chaining both of these and see what happens

#+BEGIN_EXAMPLE
      #.booking.for 3 #.booking.from 2
3 0
#+END_EXAMPLE

hm, this seems odd, this is certainly not what we expected. What if we put in some
parenthesis around the from?

#+BEGIN_EXAMPLE
      #.booking.for 3 (#.booking.from 2)
┌→────────────┬─────────────┬─────────────┐
│2 3 4 5 6 7 8│0 0 0 0 0 0 0│0 0 0 0 0 0 0│
└~───────────→┴~───────────→┴~───────────→┘
#+END_EXAMPLE

well, this also looks odd, what happened here is that 3 take ↑ on an array will
take the array and then APL will produce two more elements to allow the 3 ↑ to 
return something sensible. For an integer array of length 7, the fill element is
an integer array of length 7 withh all zeroes. This leads me to conclude that
=⍵[2]= is considered as an enclosed array (⊂ 2 3 4 5 6 7 8)

#+BEGIN_EXAMPLE
     3 ↑ ⊂ 2 3 4 5 6 7 8
┌→────────────┬─────────────┬─────────────┐
│2 3 4 5 6 7 8│0 0 0 0 0 0 0│0 0 0 0 0 0 0│
└~───────────→┴~───────────→┴~───────────→┘

    ⍝ which is NOT the same as 

     3 ↑ 2 3 4 5 6 7 8
2 3 4
#+END_EXAMPLE

it is still to early for you to realize this, but what was originally happening
was that in the the expression =#.booking.for 3 #.booking.from 2= the 3 is passed
as the left (⍺) argument to =#.booking.from=. So, what we need to do with our DSL
is to accept the left argument and just pass it on. Let us redefine the 'from'
function.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.from'
     ∇ from←{⍺,(¯1+⍵)↓⍳8}
     ∇
#+END_EXAMPLE

The result of from will now be one array with the left argument tacked on in the
beginning of the array. Let us redefine for to take the first element as the 
number of elements to take.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.for'
     ∇ for←{(⊃⍵)↑1↓⍵}
     ∇
#+END_EXAMPLE

this definition is different from the previous one, so let me break it down 
for you.

#+BEGIN_EXAMPLE
     for←{ (⊃⍵)   ↑    1↓⍵   }
             ↑           ↑
             |          / \
             |        this means that I drop the first element
             |        of the array (the left argument = the 3)
            / \
            ⊃⍵ is the same as 1↑⍵, this is the first element of ⍵.
#+END_EXAMPLE

redoing the chaining should now work, but first, let us change namespace with ⎕CS
so we do not need to reference the functions with the annoying '#.booking' duplication.
First I will show you how to know which namespace I am inside at the moment.

#+BEGIN_EXAMPLE
      ⎕THIS
#
#+END_EXAMPLE

⎕THIS returns the root namespace '#', therefore we are in the root namespace.
Let us go into the #.booking namespace 

#+BEGIN_EXAMPLE
      ⎕CS #.booking
      ⎕THIS
#.booking
#+END_EXAMPLE

in here, we will be able to see all the functions with ⎕NL 3

#+BEGIN_EXAMPLE
      ⎕NL 3
for
from
init_db
#+END_EXAMPLE

time for the famous chaining again!

#+BEGIN_EXAMPLE
      for 3 from 2
2 3 4
#+END_EXAMPLE

This is great, it works just like we want it to. Now, back to the original sentence
in our DSL

#+BEGIN_EXAMPLE
      book first free on friday for 3 from 2
#+END_EXAMPLE

with a list of hours completed, what we need now is to support the day selection,
this part is expressed through 'on friday'. What we would like from this part of 
the program is either a submatrix from the fifth day, or a number 5 together with 
the array of hours from the previous part of the chain.
I will aim for the submatrix part, returning a 4 x H matrix where H is the length
of the array we got as a result of the 'from' function.

Let's start by defining friday as a number

#+BEGIN_EXAMPLE
      friday←5
      friday
5
#+END_EXAMPLE

and then modifying 'for' so that it concatenates the left ⍺ argument at the front
of the resulting array. Remember to type the function name for and pressing C-e 
(control e), and to exit editing by escape and accepting the change.

#+BEGIN_EXAMPLE
     ⎕vr 'for'
     ∇ for←{⍺,(⊃⍵)↑1↓⍵}
     ∇
#+END_EXAMPLE

now the function 'on' is just a dummy function that returns exactly what is given
to it on the right side. This allows us to build a DSL with 'filler' words that 
gives the syntax a more natural feeling.

#+BEGIN_EXAMPLE
     ⎕vr 'on'
     ∇ on←{⍵}
     ∇
#+END_EXAMPLE

thus the chain now works all the way up to 'on'

#+BEGIN_EXAMPLE
      on friday for 3 from 2
5 2 3 4
#+END_EXAMPLE

now 'book first free' remains, it would be ideal if the 'book' function does
all the actual booking and just receives data necessary to perform all the
insertions in the matrix. With that goal in mind, we need to pass day index (chec),
row index (not there yet), and hour indices (check).
The role of 'first free' then seems to select the correct row, which they quite
coincidentally will do. 

'free' will be used to select all rooms (rows) in the given day (submatrix) which 
have all the time slots marked as free (set to 0). For this, I will do some 
laboration in the Dyalog APL environment with a fake cube. I create a fake cube
with two submatrices nullified.

#+BEGIN_EXAMPLE
      m←3 4 4 ⍴ ⍳ 48
      m[2;2 3;2 3 4]←0
      m
 1  2  3  4
 5  6  7  8
 9 10 11 12
13 14 15 16

17 18 19 20
21  0  0  0
25  0  0  0
29 30 31 32

33 34 35 36
37 38 39 40
41 42 43 44
45 46 47 48
#+END_EXAMPLE

Now I want to find the expression that returns the indices of the rows in the second
submatrix for which the columns 2 3 4 are all zero. First, let us pass the same kind
of data =2 2 3 4= to tour dynamic function as we get from our chain expression.
We start by selecting the second submatrix, and all the interesting columns.

#+BEGIN_EXAMPLE
      { m[⊃2;;1↓⍵] } 2 2 3 4
18 19 20
 0  0  0
 0  0  0
30 31 32
#+END_EXAMPLE

next we need to check if the columns add up to 0 (meaning they are all zero).
This is achieved with plus-reduction over the selected submatrix, and testing
equality with zero over the array

#+BEGIN_EXAMPLE
      { +/m[⊃2;;1↓⍵] } 2 2 3 4
57 0 0 93
      { 0=+/m[⊃2;;1↓⍵] } 2 2 3 4
0 1 1 0
#+END_EXAMPLE

next we use this binary array to select the indices of the rows with 'compress' /.
We generate all the indices of the rows by generating all numbers from 1 to (2⊃⍴m)
which is the second dimension of the cube - using ⍳.

#+BEGIN_EXAMPLE
     { (0=+/m[⊃⍵;;1↓⍵])/(⍳2⊃⍴m) } 2 2 3 4
2 3
#+END_EXAMPLE

and this is it, this will be our new function we will add to #.booking, however,
we wish to pass this result together with all the other data, so we should put
this at the front of the data we got. I defined the dynamic function on multiple
lines as it becomes more readable with variable assignments of intermedia results.

:     ⎕vr 'free'
:     ∇ free←{ba←0=+/#.db[⊃⍵;;1↓⍵]
: [1]       r←ba/⍳2⊃⍴#.db
: [2]       (⊂r),⍵}
:      ∇

trying out our new function with =]box on= shows that the result is
an array with 5 elements, the first element being the rows which 
are free.

#+BEGIN_EXAMPLE
      free on friday for 3 from 2
┌→──────┬─┬─┬─┬─┐
│1 2 3 4│5│2│3│4│
└~─────→┴─┴─┴─┴─┘
#+END_EXAMPLE

next, 'free' selects the first number in the first element (array of indices)
and returns it together with the rest of the data.

#+BEGIN_EXAMPLE
     ⎕vr 'first'
     ∇ first←{(⊃⊃⍵),1↓⍵}
     ∇
#+END_EXAMPLE

our chain works all the way up to the last piece of the puzzle.

#+BEGIN_EXAMPLE
      first free on friday for 3 from 2
1 5 2 3 4
#+END_EXAMPLE

we will now utilize this data to create the 'book' function.
The 'book' function simply indexes the correct matrix elements
and sets them to 1 (our current user id).

#+BEGIN_EXAMPLE
     ⎕vr 'book'
     ∇ book←{#.db[2⊃⍵;1⊃⍵;2↓⍵]←1}
     ∇
#+END_EXAMPLE

Let us now look at the #.db before

#+BEGIN_EXAMPLE
      #.db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

#+END_EXAMPLE

and after our full chain 

#+BEGIN_EXAMPLE

      book first free on friday for 3 from 2
      #.db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

We can now look at the booking.dyalog SALT script from outside
the environment.

#+BEGIN_EXAMPLE
> cat booking.dyalog
:NameSpace booking

    init_db←{#.db←5 4 8 ⍴ 0}
    from←{⍺,(¯1+⍵)↓⍳8}
    for←{⍺,(⊃⍵)↑1↓⍵}
    on←{⍵}
    friday←5
    free←{ba←0=+/#.db[⊃⍵;;1↓⍵]
          r←ba/⍳2⊃⍴#.db
          (⊂r),⍵}
    first←{(⊃⊃⍵),1↓⍵}
    book←{#.db[2⊃⍵;1⊃⍵;2↓⍵]←1}

:EndNameSpace
#+END_EXAMPLE
** Unbooking a room
In the same vein as before, it would be good to be able to 
unbook the room I booke before.
Given that I typed

:       book first free on friday for 3 from 2

then it would be nice to be able to say 

:       unbook booked on friday for 3 from 2

the assumption is that each user's command is executed with the
assumption that the user can only manipulate his/her own bookings.

