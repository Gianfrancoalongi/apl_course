 APL by example, an inductive course for the curious mind.

The target audience for this course, is anyone who is curious.
You will be immediately thrown into Dyalog APL with expressions you can
enter yourself in the Dyalog APL session.
While we walk through several short and sweet example programs, I will hold
your hand along the way - telling you what I think and trying to answer the
questions I would imagine you had, if you where sitting next to me right now,
as I type this.
I expect you to try out partial expressions in your Dyalog APL environment.
For example, when I show you this

#+BEGIN_EXAMPLE
     ~  2|  5 5 ⍴ ⍳ 25
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0
#+END_EXAMPLE

I expect you to try out the different sub-expressions, let's start by just 
removing from the left and re-evaluating the expression again.
And, one thing I forgot to say before; APL is evaluated from the right to the left.
Removing the tilde =~= and re-evaluating, shows that the pattern has been inverted.

#+BEGIN_EXAMPLE
     2|  5 5 ⍴ ⍳ 25
1 0 1 0 1
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0
1 0 1 0 1
#+END_EXAMPLE

perhaps tilde =~= inverts a bit pattern, kind of like negation?
Next, we remove the =2|= part and re-run

#+BEGIN_EXAMPLE
     5 5 ⍴ ⍳ 25
 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
#+END_EXAMPLE

this time, we get a 5 row by 5 columns matrix of all numbers from 1 to 25.
Notice that we went from a bit pattern to a sequence of numbers from 1 to 25,
so what can =2|= mean? Overlaying the bit pattern and the numbers, we see that
we got 1 for 1, 0 for 2, 1 for 3, 0 for 4,... perhaps =2|= is modulo with 2?
If so, it is interesting that it works on a whole matrix!

Seeing 5 5 on the left part of rho =⍴=, we can understand that this is connected
somehow. What if we remove the 5 5?

#+BEGIN_EXAMPLE
    ⍴ ⍳ 25
25
#+END_EXAMPLE 

Interesting, we got the number 25, not sure how to interpret this? That is okay, 
there will be several examples that will help the proverbial coin to drop. 
Next, let us remove the 'rho' =⍴= as well, and observe.

#+BEGIN_EXAMPLE
    ⍳ 25
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
#+END_EXAMPLE

Aha, so the 'iota' =⍳= seems to be some kind of sequence generator!
So, reading the original expression

:  ~  2|  5 5 ⍴ ⍳ 25

from right to left, we generate all numbers from 1 to 25. We then reshape
this sequence into a 5 5 matrix and then do modulo 2 on all numbers
of this matrix, and finally invert it.
See? It was easy!


I will expect you to do this kind of fearless trials in the Dyalog APL 
environment, prodding and observing expressions when you don't understand them.
Exploring solutions and the data in the Dyalog APL environment is a very natural
and normal way for APL developers to work. 

Sometimes you don't know what the correct result will be like beforehand,
but when you see the correct solution, you know it is the one!

* The Caesar cipher - implementing and breaking
The Caesar cipher is a simple substitution cipher where the cipher is the result
of rotating the alphabet and re-encoding. The encryption key is the corresponding
rotation necessary. Confused? Don't be! Here are some examples.

#+BEGIN_EXAMPLE
     0 caesar 'abba' 
abba
    
     1 caesar 'abba'
bccb

     2 caesar 'abba'
cddc
#+END_EXAMPLE

** Implementation

The encryption algorithm is quite simple

#+BEGIN_EXAMPLE
  1. Rotate the encoding alphabet N steps : N is the encryption key 
  2. For every character C in the input text
     2.1 Let I be the index of C in the normal alphabet
     2.2 Encode C with the character found at index I 
         from the rotated encoding alphabet
#+END_EXAMPLE

Lets start of with the rotation of the alphabet, first we need an alphabet to work on.
We make this simple and assume that only alphabetic characters can be used. 
Let's define the alphabet, this can be done in two ways, I will show both ways here. 
First we can do it by assigning the whole alphabet in a string.

#+BEGIN_EXAMPLE
      alphabet←'abcdefghijklmnopqrstuvwxyz'
      alphabet
abcdefghijklmnopqrstuvwxyz
#+END_EXAMPLE

the other way is to use the Unicode Convert system function ⎕UCS. It suffices to say
that it can encode the ASCII number to the appropriate alphabetic character. 
Since the alphabet in this case consists of 26 characters, we generate 26 numbers.

#+BEGIN_EXAMPLE
      ⍳26
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
#+END_EXAMPLE

next, we know that lowercase 'a' is on 97, so we shift this sequence by 96.

#+BEGIN_EXAMPLE
      96 + ⍳26
97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122
#+END_EXAMPLE

using ⎕UCS we can now get the full alphabet we want

#+BEGIN_EXAMPLE
      alphabet←⎕UCS 96 + ⍳26
      alphabet
abcdefghijklmnopqrstuvwxyz
#+END_EXAMPLE

Now we want to be able to rotate the alphabet with an encryption key (a number).
This is easily done with the 'circle stile' (rotate) ⌽.

#+BEGIN_EXAMPLE
      rotate←{ ⍵ ⌽ alphabet }
      rotate
 ∇rotate
#+END_EXAMPLE

Did you notice the del =∇= in front of the function name =rotate= after 
entering rotate and pressing enter in the Dyalog APL environment?
The =∇= indicates that =rotate= is a function and not a variable holding
an array or a scalar. There are different ways to list which functions
and variables we have available to us in our workspace at this point.
To list variables, we can use the System Command List Global Defined Variables.

#+BEGIN_EXAMPLE
   )vars
alphabet
#+END_EXAMPLE

To list the functions, we use the System Command List Global Defined Functions.

#+BEGIN_EXAMPLE
   )fns
rotate
#+END_EXAMPLE

System Commands can only be entered by the user in the Dyalog APL environment, 
and can not be used in Dyalog APL source code. If we wish to use the same
functionality as System Commands, but in source code, we use System Functions.
The System Function =Name List= with different arguments will give the same
functionality as the System Commands.

#+BEGIN_EXAMPLE
  ⎕NL 2
alphabet
#+END_EXAMPLE

and for functions, it is invoked with 3 instead.

#+BEGIN_EXAMPLE
  ⎕NL 3
rotate
#+END_EXAMPLE

=Name List= can actually take an array of input arguments, so we can do the
following

#+BEGIN_EXAMPLE
  ⎕NL 2 3
alphabet
rotate
#+END_EXAMPLE

Let us end this little detour by learning how to actually show the definition
of a function! We use the System Function =Vector Representation= for this.

#+BEGIN_EXAMPLE
     ⎕vr 'rotate'
     ∇ rotate←{⍵⌽alphabet}
     ∇
#+END_EXAMPLE

Lastly, we can also use the System Function =Canonical Representation= for
the same thing.

#+BEGIN_EXAMPLE
     ⎕cr 'rotate'
 rotate←{⍵⌽alphabet}
#+END_EXAMPLE

Now, try invoking the direct function (d-fn) rotate which we just defined.

#+BEGIN_EXAMPLE
      rotate 0
abcdefghijklmnopqrstuvwxyz
      rotate 1
bcdefghijklmnopqrstuvwxyza
      rotate 2
cdefghijklmnopqrstuvwxyzab
#+END_EXAMPLE

What remains is to find the index of the letters in the input text.
This is also very simple, thanks to Dyalog APL. 
We use 'iota' ⍳ for this, in 'dyadic' form (two arguments, one to the left
and one to the right). 

#+BEGIN_EXAMPLE
     indices_in_alphabet ←{ alphabet ⍳ ⍵ }
     indices_in_alphabet 'abbacus'
1 2 2 1 3 21 19
#+END_EXAMPLE

Using these indices, we would now like to select letters from the rotated
alphabet. This is actually encoding the message using the encryption key. 

#+BEGIN_EXAMPLE
      caesar ←  { rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alphabet ⍵]}
#+END_EXAMPLE

'diamond' ⋄ is just a newline indicator which used when writing oneliners
in the Dyalog APL environment. The code above is semantically equivalent 
to

#+BEGIN_EXAMPLE
      caesar ←  { rotated←(rotate ⍺),' '
                  rotated[indices_in_alphabet ⍵]
                }
#+END_EXAMPLE

the first line means that we assign the rotated alphabet with the space character
at the end. This because we want to be able to encode spaces as well.
When inquiring for the indices, the space character will not be part of the normal
alphabet, and so a number which is 1 higher than the length of the normal alphabet 
will be returned.

#+BEGIN_EXAMPLE
      alphabet  ⍳ ' a '
27 1 27
#+END_EXAMPLE

thus, adding the space at the end of the rotated alphabet, ensures that we take
care of encoding spaces as well. Note the behavior of dyadic iota =⍳=, and 
how this implementation is only working for lowercase a-z and that everything
else will be encoded as a space. Let me demonstrate this as follows.

#+BEGIN_EXAMPLE
     rotated ← (rotate 1),' '
     indices_in_alphabet '.;:!'
27 27 27 27
     '[',rotated[indices_in_alphabet '.;:!'],']'
[    ]
#+END_EXAMPLE

we can now try some examples

#+BEGIN_EXAMPLE
      0 caesar 'attack at dawn when the enemy soldiers are still sleeping'
attack at dawn when the enemy soldiers are still sleeping
      1 caesar 'attack at dawn when the enemy soldiers are still sleeping'
buubdl bu ebxo xifo uif fofnz tpmejfst bsf tujmm tmffqjoh
      2 caesar 'attack at dawn when the enemy soldiers are still sleeping'
cvvcem cv fcyp yjgp vjg gpgoa uqnfkgtu ctg uvknn unggrkpi
#+END_EXAMPLE

So, how do we decipher a caesar cipher if we know the key?
Simple, we just apply the negative rotation.

#+BEGIN_EXAMPLE
      clear_text←'attack at dawn when the enemy soldiers are still sleeping'
      key←12
      cipher← key caesar clear_text
      cipher
mffmow mf pmiz itqz ftq qzqyk eaxpuqde mdq efuxx exqqbuzs
      (¯1×key) caesar cipher
attack at dawn when the enemy soldiers are still sleeping
#+END_EXAMPLE

** Breaking the caesar cipher with a lookup attack

The caesar ciphers we can produce now are vulnerable to brute force
attacks, where the attacker will try all 26 possible counter rotations 
and looking up results in a dictionary. The lookup attack algorithm is quite simple.

#+BEGIN_EXAMPLE
 1. Try all 26 possible counter-rotations
 2. For every counter-rotation R_i
    2.1 check how many words from the possibly decrypted text can be
        found in a dictionary, this is the score S_i of R_i.
 3. The counter-rotation R_i with the highest score S_i is the most
    probable key.       
#+END_EXAMPLE

Let's try doing this ourselves! We start by generating a random key between 1 and 26, 
we use the roll '?' operator for this.

#+BEGIN_EXAMPLE
      clear_text←'attack at dawn when the enemy soldiers are still sleeping'
      key ← ? 26
      cipher  ←  key caesar clear_text
      cipher
dwwdfn dw gdzq zkhq wkh hqhpb vroglhuv duh vwloo vohhslqj
#+END_EXAMPLE

Now, let's try 26 possible counter-rotations, this is done by generating
all numbers from ¯26 to ¯1. We can do so by multiplying all numbers from 1
to 26 with a negative one =¯1= (notice that this is ¯1 and not -1) as seen below

#+BEGIN_EXAMPLE
      (¯1 × ⍳ 26)
¯1 ¯2 ¯3 ¯4 ¯5 ¯6 ¯7 ¯8 ¯9 ¯10 ¯11 ¯12 ¯13 ¯14 ¯15 ¯16 ¯17 ¯18 ¯19 ¯20 ¯21 ¯22 ¯23 ¯24 ¯25 ¯26
#+END_EXAMPLE

Or, by using Negate (monadic minus sign) as shown below

#+BEGIN_EXAMPLE
      -⍳26
¯1 ¯2 ¯3 ¯4 ¯5 ¯6 ¯7 ¯8 ¯9 ¯10 ¯11 ¯12 ¯13 ¯14 ¯15 ¯16 ¯17 ¯18 ¯19 ¯20 ¯21 ¯22 ¯23 ¯24 ¯25 ¯26
#+END_EXAMPLE

The difference between High Minus =¯= and Monadic Minus =-= is that High Minus
is used to enter negative numbers without need of parenthesis.

What we want to do now, is to use the caesar cipher with each and every key,
on the cipher text. For this, we can use two different approaches, first we can utilize what is called 
'outer product' with the caesar d-fn (∘.caesar). This is just distributing the left arguments over the function
and the right argument.

#+BEGIN_EXAMPLE
      (-⍳26) ∘.caesar ⊂cipher
 ....this is a lot of text
#+END_EXAMPLE

Observe this elucidating example in order to understand how the outer product =∘.⎕= works (⎕ is a function).
A similar and more elegant way is to use each =¨= which will automatically pair each left side
with the right side through some function, look at this elucidating example

#+BEGIN_EXAMPLE
      (⍳10) ,¨ 1
┌→──┬───┬───┬───┬───┬───┬───┬───┬───┬────┐
│1 1│2 1│3 1│4 1│5 1│6 1│7 1│8 1│9 1│10 1│
└~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~─→┴~──→┘
#+END_EXAMPLE

now this is how the usage of each =¨= together with the caesar function will look like 

#+BEGIN_EXAMPLE
      (-⍳26) caesar ¨ ⊂cipher
#+END_EXAMPLE

We had to 'enclose' ⊂ the right argument to turn it into a scalar so that there is only 'one thing' (a scalar)
for the each to compose the caesar function with. We can make this more readable by creating a rectangular matrix 
of the result, because we get an array of 26 elements (one caesar-application for every negative key),
and every element is as long as the cipher text, we can build a 26 by 57 matrix, using 'mix' =↑=. 
Let's check that the mental calculation is correct by asking for the dimensions of the result, using 'shape' ⍴.

#+BEGIN_EXAMPLE
      ⍴ ↑ (-⍳26) caesar ¨ ⊂cipher
26 57
#+END_EXAMPLE

Yep, 26 rows and 57 columns.

#+BEGIN_EXAMPLE
      ↑ (-⍳26) caesar ¨ ⊂cipher
cvvcem cv fcyp yjgp vjg gpgoa uqnfkgtu ctg uvknn unggrkpi
buubdl bu ebxo xifo uif fofnz tpmejfst bsf tujmm tmffqjoh
attack at dawn when the enemy soldiers are still sleeping
zsszbj zs czvm vgdm sgd dmdlx rnkchdqr zqd rshkk rkddohmf
yrryai yr byul ufcl rfc clckw qmjbgcpq ypc qrgjj qjccngle
xqqxzh xq axtk tebk qeb bkbjv pliafbop xob pqfii pibbmfkd
wppwyg wp zwsj sdaj pda ajaiu okhzeano wna opehh ohaalejc
voovxf vo yvri rczi ocz zizht njgydzmn vmz nodgg ngzzkdib
unnuwe un xuqh qbyh nby yhygs mifxcylm uly mncff mfyyjcha
tmmtvd tm wtpg paxg max xgxfr lhewbxkl tkx lmbee lexxibgz
sllsuc sl vsof ozwf lzw wfweq kgdvawjk sjw kladd kdwwhafy
rkkrtb rk urne nyve kyv vevdp jfcuzvij riv jkzcc jcvvgzex
qjjqsa qj tqmd mxud jxu uduco iebtyuhi qhu ijybb ibuufydw
piiprz pi splc lwtc iwt tctbn hdasxtgh pgt hixaa hattexcv
ohhoqy oh rokb kvsb hvs sbsam gczrwsfg ofs ghwzz gzssdwbu
nggnpx ng qnja jura gur rarzl fbyqvref ner fgvyy fyrrcvat
mffmow mf pmiz itqz ftq qzqyk eaxpuqde mdq efuxx exqqbuzs
leelnv le olhy hspy esp pypxj dzwotpcd lcp detww dwppatyr
kddkmu kd nkgx grox dro oxowi cyvnsobc kbo cdsvv cvoozsxq
jccjlt jc mjfw fqnw cqn nwnvh bxumrnab jan bcruu bunnyrwp
ibbiks ib liev epmv bpm mvmug awtlqmza izm abqtt atmmxqvo
haahjr ha khdu dolu aol lultf zvskplyz hyl zapss zsllwpun
gzzgiq gz jgct cnkt znk ktkse yurjokxy gxk yzorr yrkkvotm
fyyfhp fy ifbs bmjs ymj jsjrd xtqinjwx fwj xynqq xqjjunsl
exxego ex hear alir xli iriqc wsphmivw evi wxmpp wpiitmrk
dwwdfn dw gdzq zkhq wkh hqhpb vroglhuv duh vwloo vohhslqj
#+END_EXAMPLE

visual inspection shows that the third row from the top is very readable, 
this would put the randomized key to be 3.
Let's check.

#+BEGIN_EXAMPLE
      key
3
#+END_EXAMPLE

But what if we want this to be totally automated? If we have many (thousands!) ciphers, 
we would like the computer to do this for us and avoid having to do visual inspection.
This is where the lookup part of the attack comes into play.
Lets start by declaring the dictionary 

#+BEGIN_EXAMPLE
      dictionary ← 'soldier' 'attack' 'dawn' 'swords' 'blood'
#+END_EXAMPLE

The dictionary is now an array with 5 elements, each one being a text-array.
We can once again use 'shape' ⍴ to verify this, or 'tally' ≢.

#+BEGIN_EXAMPLE
     ⍴ dictionary
5
     ≢ dictionary
5
#+END_EXAMPLE

Before we progress further, let me take a brief moment and describe the difference
between shape (monadic rho) =⍴= and tally (monadic not equal underbar) =≢=.
Shape returns an integer vector representing the dimensions of the right argument.
Observe the result for a scalar, an array, a matrix and a cube.

#+BEGIN_EXAMPLE
      (scalar array matrix cube)←1 (⍳10) (2 2⍴⍳4) (3 2 2⍴⍳8)
      ⍴ scalar

      ⍴ array
10
      ⍴ matrix
2 2
      ⍴ cube
3 2 2
#+END_EXAMPLE

Note how the result of shape on a scalar is an empty vector. A common concept when
talking about the shape of something, is to talk about the rank. rank is defined 
as the shape of the shape. Observe the ranks of these results.

#+BEGIN_EXAMPLE
      ⍴⍴ scalar
0
      ⍴⍴ array
1
      ⍴⍴ matrix
2
      ⍴⍴ cube
3
#+END_EXAMPLE

Now contrast this with tally =≢=, tally will always return a simple scalar indicating
the amount of major cells of the right argument - or equally correct: the length of the
leading axis xor 1 if the right argument is a scalar. Observe the tally of a scalar, 
an array, a matrix and a cube. The major cells for a vector are the elements. The major cells of
a matrix are its rows, and the major cells of a cube are the matrices along the first 
dimension.

#+BEGIN_EXAMPLE
      (scalar array matrix cube)←1 (⍳10) (2 2⍴⍳4) (3 2 2⍴⍳8)
      ≢ scalar
1
      ≢ array
10
      ≢ matrix
2
      ≢ cube
3
#+END_EXAMPLE

Let's now define the lookup function that takes a piece of text, splits it into 
words and tries to see how many of these words exist in the dictionary. In order
to achieve this, we will first write a function that splits a text array on
spaces and returns an array of text arrays. This function is commonly called
'words', tokens or split in other languages. Let us call it words.

#+BEGIN_EXAMPLE 
     words ← {t←' ',⍵⋄1↓¨(t=' ')⊂t}
     ]box on
Was OFF
      words 'hello there how are you'
┌→────┬─────┬───┬───┬───┐
│hello│there│how│are│you│
└────→┴────→┴──→┴──→┴──→┘
#+END_EXAMPLE

The direct function =words= uses partitioned enclose (dyadic left shoe =⊂=),
to split the text array into an array of words, let us go through the main components
step by step in order to gain a full understanding of what is going on here.

#+BEGIN_EXAMPLE 
      a←'hello there how are you'
      t←' ',a
      t
 hello there how are you
      (t=' ')⊂t
┌→─────┬──────┬────┬────┬────┐
│ hello│ there│ how│ are│ you│
└─────→┴─────→┴───→┴───→┴───→┘
      1↓¨((t=' ')⊂t)
┌→────┬─────┬───┬───┬───┐
│hello│there│how│are│you│
└────→┴────→┴──→┴──→┴──→┘
#+END_EXAMPLE

We now want to know many of the words exist in the dictionary. This is done
by means of member =∊= and a plus-reduce.

#+BEGIN_EXAMPLE
     ws ←  words 'attack  at  dawn  when  the  enemy  soldiers  are  still  sleeping'
     ws ∊ dictionary
1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#+END_EXAMPLE

This produces a binary array where each 1 indicates that the element at that position 
in the left argument could be found in the right argument to member. If we now reduce
this with plus-reduce, we will get the correct amount of matches.

#+BEGIN_EXAMPLE
     +/ ws ∊ dictionary
2
     ⍴ +/ ws ∊ dictionary

#+END_EXAMPLE

We can see that this is a scalar result since shape reports an empty result. This means 
that there is no dimension on the argument to shape. Scalars are dimension-less in APL. 
We now have the recipe for the score calculation, and we can define our direct function.

#+BEGIN_EXAMPLE
      score ← { +/ (words ⍵) ∊ dictionary }
#+END_EXAMPLE

and we test it with our decrypted text.

#+BEGIN_EXAMPLE
      score 'attack  at  dawn  when  the  enemy  soldiers  are  still  sleeping'
2
#+END_EXAMPLE

we have the rotations, and we have the scores, now we need to apply the rotations,
and calculate the scores, selecting the rotation with highest score.
With Dyalog APL - this is simple. Once again, let's do this stepwise in the Dyalog APL 
environment, and once we have 'found the recipe' we put it into a d-fn.

#+BEGIN_EXAMPLE
      rotations ← -⍳26
      scores ← score ¨ rotations caesar ¨ ⊂cipher
#+END_EXAMPLE
 
now we want to know which score is the highest ranked one, this can be done by aquiring
the descending order of indices as they can be used to retrieve the sorted result 
from an array. The function is called 'grade down' ⍒.
And once again, an example is in order.

#+BEGIN_EXAMPLE
      ⍒ 3 1 4 6 2
4 3 1 5 2
#+END_EXAMPLE

so, what we want is to 'grade down' the scores and take the first index in the array.

#+BEGIN_EXAMPLE
      ⍒ scores
3 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
#+END_EXAMPLE

we can take the first by using 'take' ↑.

#+BEGIN_EXAMPLE
      1 ↑ ⍒ scores
3
#+END_EXAMPLE

And to finalize this, we should negate the result.

#+BEGIN_EXAMPLE
      rotations ← -⍳26
      scores ← score ¨ rotations caesar ¨ ⊂cipher
      ¯1 × 1 ↑ ⍒ scores
#+END_EXAMPLE

therefore, our function break can now be defined

#+BEGIN_EXAMPLE
      break ← {rs ← -⍳26 ⋄ ss ← score ¨ rs caesar ¨ ⊂⍵ ⋄ ¯1×1↑⍒ss }
#+END_EXAMPLE

and we can test it immediately with a new randomized cipher

#+BEGIN_EXAMPLE
      text ← 'the attack failed at dawn'
      key←?26
      cipher←key caesar text
      cipher
nby unnuwe zucfyx un xuqh
      break cipher
¯20
      ¯20 caesar cipher
the attack failed at dawn
#+END_EXAMPLE

the full listing of the functions we have defined can be seen by listing
the functions in the current workspace.

#+BEGIN_EXAMPLE
      )fns
break   caesar  indices_in_alphabet      rotate  score
#+END_EXAMPLE

we can now use 'vector representation' to display the definition of every 
function.

#+BEGIN_EXAMPLE
      ⎕vr ¨ 'break' 'caesar' 'score' 'rotate' 'indices_in_alphabet'
      ∇ break←{rs←-⍳26 ⋄ ss← score ¨ rs caesar ¨ ⊂⍵ ⋄ ¯1×1↑⍒ss}
      ∇ caesar←{rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alphabet ⍵]}
      ∇ score ← { +/ (words ⍵) ∊ dictionary }
      ∇ rotate←{⍵⌽alphabet}
      ∇ indices_in_alphabet←{alphabet⍳⍵}
#+END_EXAMPLE

** Breaking the securer caesar cipher

There is one thing that can be done to make the caesar cipher slightly trickier
to break. If we remove all spaces so that word boundaries become anonymous, we will
not be able to break the 26 rotations into substrings and look them up in the dictionary,
but we would be able to do the reverse; find matching substrings in the 26 rotations
with the dictionary words. An alternate and more interesting approach, would be
to measure the letter frequency, and see if it aligns with the letter frequency of
proper english.
Instead of passing 'hello world how are you' to the encryption algorithm, we will pass
an equivalent of 'helloworldhowareyou'. The algorithm for breaking the slightly harder to break
caesar cipher is thus

#+BEGIN_EXAMPLE
 1. Try all 26 possible counter-rotations
 2. For every counter-rotation R_i
    2.1 F_i is the measured letter frequency of the resulting text.
        Calculate the distance D_i between english letter frequency and F_i
 3. The counter-rotation R_i with the lowest distance D_i is the most
    probable key.
#+END_EXAMPLE

Lets start by copying our cleartext from a predefined workspace called frequency.ws.
We do this by utilizing the system function Copy =⎕CY= which will copy all or just the
named object from another workspace (if any names are passed as the left argument).

#+BEGIN_EXAMPLE
   ⎕CY './frequency.ws'
   ⍴text
476
   text
thefirstincarnationofwhatwaslatertobet.....
#+END_EXAMPLE

What we need now, is a d-fn for measuring letter frequency in a text.
For each letter in the alphabet, we wish to count the amount of times it occurrs in 
a text, and then divide this by the length of the text.
We utilize the outer product once again, with the alphabet; in the example below,
we do the following: for each of the 26 letters in the alphabet, perform array
comparison with the given text to the left, letter by letter inside it.

#+BEGIN_EXAMPLE
      alphabet ∘.= 'abbacuswasatoolforcalculations'
1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#+END_EXAMPLE

what remains now, is to sum the 1's for each row, this is plus-reduce again.

#+BEGIN_EXAMPLE
      +/ alphabet ∘.= 'abbacuswasatoolforcalculations'
6 2 3 0 0 1 0 0 1 0 0 3 0 1 4 0 0 1 3 2 2 0 1 0 0 0
#+END_EXAMPLE

we can now see that there are 6 a's in the text, 2 b's etc, what now remains is to 
divide by the length of the text in question, we do this by a direct function
and passing the text.

#+BEGIN_EXAMPLE
     { (+/ alphabet ∘.= ⍵) ÷ ⍴⍵ } 'abbacuswasatoolforcalculations'
0.2 0.06666666667 0.1 0 0 0.03333333333 0 0 0.03333333333 0 0 0.1 0 0.03333333333......
#+END_EXAMPLE

Let us name this frequency, and amaze at the conciseness.

#+BEGIN_EXAMPLE
      frequency ← { (+/alphabet∘.=⍵)÷⍴⍵ }
      frequency text
0.1029411765 0.01470588235 0.03571428571 ......
#+END_EXAMPLE

Next up, we need to compare how close a measured letter frequency is to the english 
letter frequency, for that we need the english letter frequency (which I happen to have added).
When we copied the workspace =frequency.ws= with the system function =⎕CY= we also 
got the variable =english= which contains an array of english monogram letter frequencies.
Take a look at it by reshaping it as a 13 2 matrix after concatenating it with the alphabet.

#+BEGIN_EXAMPLE
     13 2 ⍴ alphabet ,¨  english
┌→────────┬─────────┐
↓a 0.08167│b 0.01492│
├+───────→┼+───────→┤
│c 0.02782│d 0.04253│
├+───────→┼+───────→┤
│e 0.12702│f 0.02228│
├+───────→┼+───────→┤
│g 0.02015│h 0.06094│
├+───────→┼+───────→┤
│i 0.06966│j 0.00153│
├+───────→┼+───────→┤
│k 0.00772│l 0.04025│
├+───────→┼+───────→┤
│m 0.02406│n 0.06749│
├+───────→┼+───────→┤
│o 0.07507│p 0.01929│
├+───────→┼+───────→┤
│q 0.00095│r 0.05987│
├+───────→┼+───────→┤
│s 0.06327│t 0.09056│
├+───────→┼+───────→┤
│u 0.02758│v 0.00978│
├+───────→┼+───────→┤
│w 0.0236 │x 0.0015 │
├+───────→┼+───────→┤
│y 0.01974│z 0.00074│
└+───────→┴+───────→┘
#+END_EXAMPLE

However, when working with the array =english= we want it just as a pure floating point
array (as it is).

#+BEGIN_EXAMPLE
      english
0.08167 0.01492 0.02782 0.04253 0.12702 0.02228 .....
#+END_EXAMPLE

Now we can write the d-fn for performing the calculation of euclidean distance between two vectors.
This is no more than the square root of the sum of the squares of distances.

#+BEGIN_EXAMPLE
      distance ← { sqd←(⍺-⍵)*2 ⋄ sum←+/sqd ⋄ sum*0.5 }
#+END_EXAMPLE

Notice how the d-fn for distance has ⍺ and ⍵. This is because distance is dyadic, it will take a left
argument and a right argument. ⍺ is the left argument, and ⍵ is the right argument.
We can test it out with multiple vectors. Actually, let's calculate the euclidean distance to all discrete
carthesian products in the range (1 1) to (10 10). We can easily produce all such pairs with monadic iota ⍳. 

#+BEGIN_EXAMPLE
      ⍳ 10 10
 1 1   1 2   1 3   1 4   1 5   1 6   1 7   1 8   1 9   1 10
 2 1   2 2   2 3   2 4   2 5   2 6   2 7   2 8   2 9   2 10
 3 1   3 2   3 3   3 4   3 5   3 6   3 7   3 8   3 9   3 10
 4 1   4 2   4 3   4 4   4 5   4 6   4 7   4 8   4 9   4 10
 5 1   5 2   5 3   5 4   5 5   5 6   5 7   5 8   5 9   5 10
 6 1   6 2   6 3   6 4   6 5   6 6   6 7   6 8   6 9   6 10
 7 1   7 2   7 3   7 4   7 5   7 6   7 7   7 8   7 9   7 10
 8 1   8 2   8 3   8 4   8 5   8 6   8 7   8 8   8 9   8 10
 9 1   9 2   9 3   9 4   9 5   9 6   9 7   9 8   9 9   9 10
 10 1  10 2  10 3  10 4  10 5  10 6  10 7  10 8  10 9  10 10
#+END_EXAMPLE

let us now perform outer product with distance to 1 1 (and produce a text result 
where the numbers are rounded to two decimals, with the use of format by specification 
(down tack jot) =⍕=).

#+BEGIN_EXAMPLE
      2 ⍕ (⍳ 10 10) distance ¨ ⊂(1 1)
 0.00 1.00 2.00 3.00 4.00  5.00  6.00  7.00  8.00  9.00
 1.00 1.41 2.24 3.16 4.12  5.10  6.08  7.07  8.06  9.06
 2.00 2.24 2.83 3.61 4.47  5.39  6.32  7.28  8.25  9.22
 3.00 3.16 3.61 4.24 5.00  5.83  6.71  7.62  8.54  9.49
 4.00 4.12 4.47 5.00 5.66  6.40  7.21  8.06  8.94  9.85
 5.00 5.10 5.39 5.83 6.40  7.07  7.81  8.60  9.43 10.30
 6.00 6.08 6.32 6.71 7.21  7.81  8.49  9.22 10.00 10.82
 7.00 7.07 7.28 7.62 8.06  8.60  9.22  9.90 10.63 11.40
 8.00 8.06 8.25 8.54 8.94  9.43 10.00 10.63 11.31 12.04
 9.00 9.06 9.22 9.49 9.85 10.30 10.82 11.40 12.04 12.73
#+END_EXAMPLE

The last thing we need to do now, is to combine all of this, just like we did for the lookup attack.
But, let's generate a random key and produce a cipher from the text.

#+BEGIN_EXAMPLE
      key←?26
      cipher←key caesar text
      cipher
kyvwzijkzetrie.....(a lot of text)
#+END_EXAMPLE

notice how the old break will not work on this.

#+BEGIN_EXAMPLE
      break cipher
¯1
#+END_EXAMPLE

Now, the grande finale.

#+BEGIN_EXAMPLE
      rotations←-⍳26
      distances ← english∘distance ¨ frequency ¨ rotations caesar ¨ ⊂cipher
      ¯1 × 1↑⍋distances
¯17
      ¯17 caesar cipher
thefirstincarnationofwhatwaslatertobetheapl...(lots of text)
#+END_EXAMPLE

You will notice on interesting thing, that english is next to distance in what is called
composed with (jot =∘=). This means that we compose a function with an argument so that
it has already been given an argument (this is the same as Currying). Observe the following
examples. First, we try to (incorrectly) calculate the distance from 2 2 to each of 3 3, 2 2 and 1 1.

#+BEGIN_EXAMPLE
      (2 2) distance ¨ (3 3) (2 2) (1 1)
LENGTH ERROR
      (2 2)distance¨(3 3)(2 2)(1 1)
     ∧
#+END_EXAMPLE

But this fails, and we pass a direct function to the each =¨= which works well.

#+BEGIN_EXAMPLE
      { (2 2) distance ⍵ } ¨ (3 3) (2 2) (1 1)
1.414213562 0 1.414213562
#+END_EXAMPLE

However, this is the same as passing a function which takes one argument, right?
So we create this function by composition, 'gluing' the left argument to distance
and passing this to each =¨=, this is done with jot =∘=.

#+BEGIN_EXAMPLE
      (2 2)∘distance ¨ (3 3) (2 2) (1 1)
1.414213562 0 1.414213562
#+END_EXAMPLE

The same effect can be achieved by enclosing the array 2 2 first.

#+BEGIN_EXAMPLE
      (⊂2 2) distance ¨ (3 3) (2 2) (1 1)
1.414213562 0 1.414213562
#+END_EXAMPLE

The difference to the prior algorithm is that we have frequency on 'each' ¨ result, and 
use 'grade-up' ⍋ to get the indices in an ascending order.
Clearly, ¯17 is the counter-rotation, thus the original text was encrypted with 17 as the key.
The finalizing d-fn now follows.

#+BEGIN_EXAMPLE
      freq_break←{ rs←-⍳26 ⋄ ds ← english∘distance ¨ frequency ¨ rs caesar ¨ ⊂⍵ ⋄ ¯1×1↑⍋ds }
      freq_break cipher
¯17
      ¯17 caesar cipher
thefirstincarnationofwhatwaslatertobetheapl....(lots of text)
#+END_EXAMPLE

The full listing for this frequency breaking are shown below.

#+BEGIN_EXAMPLE
⎕vr ¨ 'freq_break' 'distance' 'frequency' 'caesar' 'rotate' 'indices_in_alphabet'
∇ freq_break←{rs←-⍳26 ⋄ ds←english∘distance ¨ frequency ¨ rs caesar ¨ ⊂⍵ ⋄ ¯1×1↑⍋ds}
∇ distance←{sqd←(⍺-⍵)*2 ⋄ sum←+/sqd ⋄ sum*0.5}
∇ frequency←{ ( +/ alphabet ∘.= ⍵ ) ÷ ⍴⍵ }
∇ caesar←{rotated←(rotate ⍺),' ' ⋄ rotated[indices_in_alphabet ⍵]}
∇ rotate←{⍵⌽alphabet}
∇ indices_in_alphabet←{alphabet⍳⍵}
#+END_EXAMPLE

** Saving the work of the day

Now that I have something interesting, I would like to save it for future reference.
Also, I would be upset if the computer crashed and all the work was lost.
We can save the work by saving the workspace, I chose to save it was warmup

#+BEGIN_EXAMPLE
      )save warmup
warmup saved Wed Apr  9 20:37:47 2014
#+END_EXAMPLE

I can now clear the workspace and see that it is really clear by listing functions
and variables

#+BEGIN_EXAMPLE
      )clear
clear ws
      )fns
      )vars
#+END_EXAMPLE

Let us load the warmup namespace again

#+BEGIN_EXAMPLE
      )load warmup
./warmup saved Wed Apr  9 20:37:47 2014
      )fns
break   caesar       distance  freq_break      frequency
indices_in_alphabet   rotate    score
      )vars
alphabet    cipher   clear_text  dictionary
distances  english  key         rotations       scores
#+END_EXAMPLE

I noticed that I have some lingering variables I wish not to have, so I will
expunge them from the workspace (here I apply ⎕ex to each name with ¨)

#+BEGIN_EXAMPLE
      ⎕ex ¨ 'key' 'rotations' 'scores' 'distances'
#+END_EXAMPLE

But what if we forget the name of our workspace?
Then we list all workspaces with )lib, this is what I get on my Linux.

#+BEGIN_EXAMPLE
      )lib
.
        warmup
/opt/mdyalog/14.0/64/unicode/ws
      apl2in   apl2pcin conga   display dwsin   dwsout   fonts   ftp   groups  newleaf ops
      postscri quadna   rainpro salt    smdemo  smdesign smtutor sqapl tutor   util
      xfrcode  xlate
/opt/mdyalog/14.0/64/unicode/samples/dfns
      ddb     dfns    eval    max     min     tube
/opt/mdyalog/14.0/64/unicode/samples/tcpip
      chat    echo    qfiles  rexec   www
/opt/mdyalog/14.0/64/unicode/samples/OO4APL
      Chapter9.DWS       ComponentFile.DWS   ExcelWorkBook.DWS  Monthly.DWS
      MonthlyAfter5.DWS  OOTools.DWS         PlanBook.DWS       PlanBookFinal.DWS  Queue.DWS
      Random.DWS         TimeSeries.DWS      derivedgui.DWS     dotnet.DWS         guitools.DWS
#+END_EXAMPLE

So, what does the workspace look like outside of the Dyalog APL environment?
It is a binary which will not be possible to interpret outside of the Dyalog APL
environment. Let's exit the Dyalog APL environment and look at it with some standard 
linux tools (strings, file and hexdump).

#+BEGIN_EXAMPLE
   ⎕OFF
$> file warmup
warmup: Dyalog APL workspace type 14 subtype 1 64-bit unicode little-endian
$> strings warmup
Dyalog
ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789
....
soldier
attack
dawn
swords
blood
ERCP
@$q8D
attack
dawn
when
enemy
soldiers
still
sleeping
...
$> head -n 2 warmup | hexdump -C
00000000  aa 03 0e 01 0e 00 fd a4  00 02 00 00 00 00 00 00  |................|
00000010  60 ea ff ff ff ff ff ff  71 00 00 00 00 00 00 00  |`.......q.......|
00000020  c0 36 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.6..............|
00000030  07 73 70 00 00 00 00 00  00 00 00 00 00 00 00 00  |.sp.............|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  80 3b 84 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |.;.9............|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000090  77 41 84 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |wA.9............|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000c0  4b 63 9b 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |Kc.9............|
000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000f0  9c 5d 9b 39 f1 7f 00 00  00 00 00 00 00 00 00 00  |.].9............|
00000100  00 00 00 00 00 00 00 00  50 f5 f7 ff ff ff ff ff  |........P.......|
00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000130  00 00 00 00 00 00 00 00  58 5b 00 00 00 00 00 00  |........X[......|
00000140  48 0a 00 00 00 00 00 00  68 0a                    |H.......h.|
0000014a
#+END_EXAMPLE

Clearly, it will be VERY difficult to put this under version control.
And this is why we will work with SALT scripts from now on.
SALT scripts are Dyalog APL files which can be read from outside the Dyalog APL
environment, just like normal source files from any other language.

* A Tiny Booking DSL 
** SALT booking namespace
A Domain Specific Language (DSL) is a language specific to a domain.
We can design our own Booking DSL easily in Dyalog APL, creating a 
set of instructions which feel natural for the users of the system.

As I mentioned in the previous chapter, we will now use Dyalog APL SALT
scripts, so we can read them from outside of the Dyalog APL environment.
Let's start by creating our first SALT script.
Use your favourite editor and create the file booking.dyalog, inside we 
put the following empty namespace.

#+BEGIN_EXAMPLE
:NameSpace booking

:EndNameSpace
#+END_EXAMPLE

we can now load this SALT script in the Dyalog APL environment using
⎕SE.SALT.Load (I assign the result to ⎕ in order to show the shy result).

#+BEGIN_EXAMPLE
      ⎕←⎕SE.SALT.Load './booking.dyalog'
#.booking
#+END_EXAMPLE

The #.booking result indicates that the root namespace # now has a namespace
inside of it, called booking, accessible through #.booking. We can list all
namespaces with ⎕NL 9

#+BEGIN_EXAMPLE
      ⎕NL 9
booking
#+END_EXAMPLE

** Creating the database
We can now add a function to initialize the room database with 4 bookable
rooms, each room has 8 bookable hours, and 5 days a week. We do this by
typing #.booking C-e (control-e). This will open an editor window, allowing
us to enter a function into the booking namespace.
But, we will close this window (escape) and experiment a bit more in the 
Dyalog APL repl.

#+BEGIN_EXAMPLE
Dyalog APL/S-64 Version 14.0.19453          ┌booking──────────────────────────────────┐
Unicode Edition                             │    :NameSpace booking                   │
Thu Apr 10 20:04:26 2014                    │                                         │
clear ws                                    │    :EndNameSpace                        │
                                            │                                         │
      ⎕←⎕SE.SALT.Load './booking.dyalog'    │                                         │
#.booking                                   │                                         │
      ⎕NL 9                                 │                                         │
booking                                     │                                         │
      #.booking                             │                                         │
                                            └⍟────────────────────────────────────────┘

#+END_EXAMPLE

But, we will close this window (escape) and experiment a bit more in the 
Dyalog APL repl. Let's start by creating a 4 (rooms) by 8 (hours) matrix
of all zeroes using reshape ⍴ in dyadic form.

#+BEGIN_EXAMPLE
    4 8 ⍴ 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

Every row represents a room and every column represents an hour, a 0 means
the room is free, a number indicates it's booked by someone with an id equal
to the number. Now, let's make a cube out of this, so we have 5 days.

#+BEGIN_EXAMPLE
   5 4 8 ⍴ 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

every matrix is one day, and the same rules apply for each such matrix as for 
the 4 8 ⍴ 0 case. This seems good enough, let us now open the #.booking
namespace by pressing C-e (control-e) on #.booking in the Dyalog environment.

#+BEGIN_EXAMPLE
:NameSpace booking

[0]       init_db  ← { #.db ← 5 4 8 ⍴ 0 }

:EndNameSpace
#+END_EXAMPLE

Remember to exit the editor by pressing escape.
When we press escape, Dyalog SALT will ask if we want to update the source
file for "#.booking", I press y for YES.

#+BEGIN_EXAMPLE
 Update source file for "#.booking"?

 If you choose YES, file </home/gianfranco/APL_course/booking.dyalog> will be overwritten.

 If you choose NO, the changes won't be filed
 Y/N? Y
#+END_EXAMPLE

We can now check that the file has been updated outside of the Dyalog APL environment
by opening it with our favourite editor, or just doing less on it.

#+BEGIN_EXAMPLE
> less booking.dyalog
:NameSpace booking

    init_db←{#.db←5 4 8 ⍴ 0}

:EndNameSpace
#+END_EXAMPLE

We have now assigned the direct function to init_db in #.booking.
We can check that the d-fn has been defined by listing the available functions
in the #.booking namespace using ⎕NL 3 from within the #.booking namespace

#+BEGIN_EXAMPLE
     #.booking.⎕NL 3
init_db
#+END_EXAMPLE

we can also visualize the function using ⎕vr (vector representation) 

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.init_db'
     ∇ init_db←{#.db←5 4 8⍴0}
     ∇
#+END_EXAMPLE

if we now run the init_db function, a db will be created in the root 
namespace. 

#+BEGIN_EXAMPLE
      )vars
      #.booking.init_db ⍬
      )vars
db
      db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

Notice how the d-fn has to be invoked with a zilde ⍬ (empty) argument.
if we don't do that, the evaluation will just return the d-fn itself.

#+BEGIN_EXAMPLE
      #.booking.init_db
{#.db←5 4 8⍴0}
#+END_EXAMPLE

** Booking a room
What if we could type the following and actually get what we expect?

#+BEGIN_EXAMPLE
      book first free on friday for 3 from 2
#+END_EXAMPLE

In case you don't really follow the intention of the above, it means
to book the first freely available room on friday for 3 hours if 
possible from the second hour and onwards.

Let's start with the rightmost (as APL is interpreted from right to left).
The 'from' function. It would be nice if this returns an array of hours
which are in the range, thus for this example

#+BEGIN_EXAMPLE
      from 2 
2 3 4 5 6 7 8
#+END_EXAMPLE

Let's start by creating all numbers up to 8, and then dropping the first
x-1.

#+BEGIN_EXAMPLE
      ⍳8
1 2 3 4 5 6 7 8
      1↓⍳8
2 3 4 5 6 7 8
#+END_EXAMPLE

we now put this into from in the #.booking namespace in the same way as before
#.booking (C-e) edit and esc, Y. We can list the source code of from with ⎕vr.

#+BEGIN_EXAMPLE
      ⎕vr '#.booking.from'
     ∇ from←{(¯1+⍵)↓⍳8}
     ∇
#+END_EXAMPLE

Next, lets write the 'for' function. It would seem appropriate for this function
to take 3 of the hours it was given as the second argument (the hours we get in from).
This is really no more than just a normal take ↑, the only thing making it interesting
for us is that we get two arguments on the right of 'for' and we need to take as many
elements from the second input argument =⍵[2]= as the first argument =⍵[1]=.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.for'
     ∇ for←{⍵[1]↑⍵[2]}
     ∇
#+END_EXAMPLE

Let us now try chaining both of these and see what happens

#+BEGIN_EXAMPLE
      #.booking.for 3 #.booking.from 2
3 0
#+END_EXAMPLE

hm, this seems odd, this is certainly not what we expected. What if we put in some
parenthesis around the from?

#+BEGIN_EXAMPLE
      #.booking.for 3 (#.booking.from 2)
┌→────────────┬─────────────┬─────────────┐
│2 3 4 5 6 7 8│0 0 0 0 0 0 0│0 0 0 0 0 0 0│
└~───────────→┴~───────────→┴~───────────→┘
#+END_EXAMPLE

well, this also looks odd, what happened here is that 3 take ↑ on an array will
take the array and then APL will produce two more elements to allow the 3 ↑ to 
return something sensible. For an integer array of length 7, the fill element is
an integer array of length 7 withh all zeroes. This leads me to conclude that
=⍵[2]= is considered as an enclosed array (⊂ 2 3 4 5 6 7 8)

#+BEGIN_EXAMPLE
     3 ↑ ⊂ 2 3 4 5 6 7 8
┌→────────────┬─────────────┬─────────────┐
│2 3 4 5 6 7 8│0 0 0 0 0 0 0│0 0 0 0 0 0 0│
└~───────────→┴~───────────→┴~───────────→┘

    ⍝ which is NOT the same as 

     3 ↑ 2 3 4 5 6 7 8
2 3 4
#+END_EXAMPLE

it is still to early for you to realize this, but what was originally happening
was that in the the expression =#.booking.for 3 #.booking.from 2= the 3 is passed
as the left (⍺) argument to =#.booking.from=. So, what we need to do with our DSL
is to accept the left argument and just pass it on. Let us redefine the 'from'
function.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.from'
     ∇ from←{⍺,(¯1+⍵)↓⍳8}
     ∇
#+END_EXAMPLE

The result of from will now be one array with the left argument tacked on in the
beginning of the array. Let us redefine for to take the first element as the 
number of elements to take.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.for'
     ∇ for←{(⊃⍵)↑1↓⍵}
     ∇
#+END_EXAMPLE

this definition is different from the previous one, so let me break it down 
for you.

#+BEGIN_EXAMPLE
     for←{ (⊃⍵)   ↑    1↓⍵   }
             ↑           ↑
             |          / \
             |        this means that I drop the first element
             |        of the array (the left argument = the 3)
            / \
            ⊃⍵ is the same as 1↑⍵, this is the first element of ⍵.
#+END_EXAMPLE

redoing the chaining should now work, but first, let us change namespace with ⎕CS
so we do not need to reference the functions with the annoying '#.booking' duplication.
First I will show you how to know which namespace I am inside at the moment.

#+BEGIN_EXAMPLE
      ⎕THIS
#
#+END_EXAMPLE

⎕THIS returns the root namespace '#', therefore we are in the root namespace.
Let us go into the #.booking namespace 

#+BEGIN_EXAMPLE
      ⎕CS #.booking
      ⎕THIS
#.booking
#+END_EXAMPLE

in here, we will be able to see all the functions with ⎕NL 3

#+BEGIN_EXAMPLE
      ⎕NL 3
for
from
init_db
#+END_EXAMPLE

time for the famous chaining again!

#+BEGIN_EXAMPLE
      for 3 from 2
2 3 4
#+END_EXAMPLE

This is great, it works just like we want it to. Now, back to the original sentence
in our DSL

#+BEGIN_EXAMPLE
      book first free on friday for 3 from 2
#+END_EXAMPLE

with a list of hours completed, what we need now is to support the day selection,
this part is expressed through 'on friday'. What we would like from this part of 
the program is either a submatrix from the fifth day, or a number 5 together with 
the array of hours from the previous part of the chain.
I will aim for the submatrix part, returning a 4 x H matrix where H is the length
of the array we got as a result of the 'from' function.

Let's start by defining friday as a number

#+BEGIN_EXAMPLE
      friday←5
      friday
5
#+END_EXAMPLE

and then modifying 'for' so that it concatenates the left ⍺ argument at the front
of the resulting array. Remember to type the function name for and pressing C-e 
(control e), and to exit editing by escape and accepting the change.

#+BEGIN_EXAMPLE
     ⎕vr 'for'
     ∇ for←{⍺,(⊃⍵)↑1↓⍵}
     ∇
#+END_EXAMPLE

now the function 'on' is just a dummy function that returns exactly what is given
to it on the right side. This allows us to build a DSL with 'filler' words that 
gives the syntax a more natural feeling.

#+BEGIN_EXAMPLE
     ⎕vr 'on'
     ∇ on←{⍵}
     ∇
#+END_EXAMPLE

thus the chain now works all the way up to 'on'

#+BEGIN_EXAMPLE
      on friday for 3 from 2
5 2 3 4
#+END_EXAMPLE

now 'book first free' remains, it would be ideal if the 'book' function does
all the actual booking and just receives data necessary to perform all the
insertions in the matrix. With that goal in mind, we need to pass day index (chec),
row index (not there yet), and hour indices (check).
The role of 'first free' then seems to select the correct row, which they quite
coincidentally will do. 

'free' will be used to select all rooms (rows) in the given day (submatrix) which 
have all the time slots marked as free (set to 0). For this, I will do some 
laboration in the Dyalog APL environment with a fake cube. I create a fake cube
with two submatrices nullified.

#+BEGIN_EXAMPLE
      m←3 4 4 ⍴ ⍳ 48
      m[2;2 3;2 3 4]←0
      m
 1  2  3  4
 5  6  7  8
 9 10 11 12
13 14 15 16

17 18 19 20
21  0  0  0
25  0  0  0
29 30 31 32

33 34 35 36
37 38 39 40
41 42 43 44
45 46 47 48
#+END_EXAMPLE

Now I want to find the expression that returns the indices of the rows in the second
submatrix for which the columns 2 3 4 are all zero. First, let us pass the same kind
of data =2 2 3 4= to tour direct function as we get from our chain expression.
We start by selecting the second submatrix, and all the interesting columns.

#+BEGIN_EXAMPLE
      { m[⊃2;;1↓⍵] } 2 2 3 4
18 19 20
 0  0  0
 0  0  0
30 31 32
#+END_EXAMPLE

next we need to check if the columns add up to 0 (meaning they are all zero).
This is achieved with plus-reduction over the selected submatrix, and testing
equality with zero over the array

#+BEGIN_EXAMPLE
      { +/m[⊃2;;1↓⍵] } 2 2 3 4
57 0 0 93
      { 0=+/m[⊃2;;1↓⍵] } 2 2 3 4
0 1 1 0
#+END_EXAMPLE

next we use this binary array to select the indices of the rows with 'compress' /.
We generate all the indices of the rows by generating all numbers from 1 to (2⊃⍴m)
which is the second dimension of the cube - using ⍳.

#+BEGIN_EXAMPLE
     { (0=+/m[⊃⍵;;1↓⍵])/(⍳2⊃⍴m) } 2 2 3 4
2 3
#+END_EXAMPLE

and this is it, this will be our new function we will add to #.booking, however,
we wish to pass this result together with all the other data, so we should put
this at the front of the data we got. I defined the direct function on multiple
lines as it becomes more readable with variable assignments of intermedia results.

:     ⎕vr 'free'
:     ∇ free←{ba←0=+/#.db[⊃⍵;;1↓⍵]
: [1]       r←ba/⍳2⊃⍴#.db
: [2]       (⊂r),⍵}
:      ∇

trying out our new function with =]box on= shows that the result is
an array with 5 elements, the first element being the rows which 
are free.

#+BEGIN_EXAMPLE
      free on friday for 3 from 2
┌→──────┬─┬─┬─┬─┐
│1 2 3 4│5│2│3│4│
└~─────→┴─┴─┴─┴─┘
#+END_EXAMPLE

next, 'free' selects the first number in the first element (array of indices)
and returns it together with the rest of the data.

#+BEGIN_EXAMPLE
     ⎕vr 'first'
     ∇ first←{(⊃⊃⍵),1↓⍵}
     ∇
#+END_EXAMPLE

our chain works all the way up to the last piece of the puzzle.

#+BEGIN_EXAMPLE
      first free on friday for 3 from 2
1 5 2 3 4
#+END_EXAMPLE

we will now utilize this data to create the 'book' function.
The 'book' function simply indexes the correct matrix elements
and sets them to 1 (our current user id).

#+BEGIN_EXAMPLE
     ⎕vr 'book'
     ∇ book←{#.db[2⊃⍵;1⊃⍵;2↓⍵]←1}
     ∇
#+END_EXAMPLE

Let us now look at the #.db before

#+BEGIN_EXAMPLE
      #.db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

#+END_EXAMPLE

and after our full chain 

#+BEGIN_EXAMPLE

      book first free on friday for 3 from 2
      #.db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

We can now look at the booking.dyalog SALT script from outside
the environment.

#+BEGIN_EXAMPLE
> cat booking.dyalog
:NameSpace booking

    init_db←{#.db←5 4 8 ⍴ 0}
    from←{⍺,(¯1+⍵)↓⍳8}
    for←{⍺,(⊃⍵)↑1↓⍵}
    on←{⍵}
    friday←5
    free←{ba←0=+/#.db[⊃⍵;;1↓⍵]
          r←ba/⍳2⊃⍴#.db
          (⊂r),⍵}
    first←{(⊃⊃⍵),1↓⍵}
    book←{#.db[2⊃⍵;1⊃⍵;2↓⍵]←1}

:EndNameSpace
#+END_EXAMPLE
** Unbooking a room
In the same vein as before, it would be good to be able to 
unbook the room I booked before.
If I previously typed
:       book first free on friday for 3 from 2
then it would be nice to be able to use some kind of booking id
which I presumably got from the previous booking.
For this example, let us assume I got a booking id of 10
:       unbook with id 10
We want the function 'book' to return a booking id when it succeeds.
Let us do this by assigning the booking id to the rooms, as this is
a simple example, let us have a global booking id (bid) counter which 
increases for each booking. We will write a function to initialize
the booking id and one function to get the next booking id and increasing
the booking id counter.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.init_bid'
     ∇ init_bid←{#.bid←1}
     ∇
#+END_EXAMPLE
and the get_next_booking_id
#+BEGIN_EXAMPLE
     ⎕vr '#.booking.get_next_bid'
     ∇ get_next_bid←{ r←#.bid ⋄ #.bid←1+r ⋄ r }
     ∇
#+END_EXAMPLE

We can now test this

#+BEGIN_EXAMPLE
      #.booking.init_bid  ⍬
      #.booking.get_next_bid ⍬
1
      #.booking.get_next_bid ⍬
2
      #.booking.get_next_bid ⍬
3
#+END_EXAMPLE

we would now like to change the book function to use the next 
available bid when booking, and returning said bid.

#+BEGIN_EXAMPLE
     ⎕vr '#.booking.book'
     ∇ book←{bid←get_next_bid ⍬⋄ #.db[2⊃⍵;1⊃⍵;2↓⍵]←bid ⋄ bid}
     ∇
#+END_EXAMPLE

Remember that the code above is semantically equivalent to the
code below on multiple lines

#+BEGIN_EXAMPLE
     ∇ book←{ bid←get_next_bid ⍬
              #.db[2⊃⍵;1⊃⍵;2↓⍵]←bid
              bid}
     ∇
#+END_EXAMPLE

Let us try this as well

#+BEGIN_EXAMPLE
      ⎕CS '#.booking'
      init_bid  ⍬
      init_db ⍬
      book first free on friday for 3 from 2
1
      book first free on friday for 3 from 2
2
      book first free on friday for 3 from 2
3
      #.db
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0

0 1 1 1 0 0 0 0
0 2 2 2 0 0 0 0
0 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0
#+END_EXAMPLE

we can now start implementing the wanted functionality
: unbook with id 10
here we note that 'with' and 'id' are probably filler
words, so they should be identity functions.

#+BEGIN_EXAMPLE
     ⎕vr 'id'
     ∇ id←{⍵}
     ∇
     ⎕vr 'with'
     ∇ with←{⍵}
     ∇
     with id 10
10
#+END_EXAMPLE

the 'unbook' function should now accept the bid and find
all matrix elements where this bid is used and release them
(set them to 0).

#+BEGIN_EXAMPLE
     ⎕vr 'unbook'
     ∇ unbook←{(,#.db)[(,#.db=⍵)/⍳⍴,#.db]←0}
     ∇
#+END_EXAMPLE

This one requires a bit of explanation, and fear not, for it
is easy! Let us break it down into steps, for this demonstration
I will set #.db to a 2 day, 4 room, 3 hour matrix of zeroes.
The hours 2 and 3 on the second and third rooms for the second
day will be booked with bid 23.

#+BEGIN_EXAMPLE
      #.db←2 4 3 ⍴ 0
      #.db
0 0 0
0 0 0
0 0 0
0 0 0

0 0 0
0 0 0
0 0 0
0 0 0
      #.db[2;2 3;2 3]←23
      #.db
0  0  0
0  0  0
0  0  0
0  0  0

0  0  0
0 23 23
0 23 23
0  0  0
#+END_EXAMPLE

Let us now look at the innermost part of the unbook expression.
:     (,#.db=⍵)
This expression tests the cube for equality with the supplied bid, 
producing a binary cube and then ravels it. Ravel is a function 
that produces an array out of any higher-order array (matrix,cube,...).
Let's test this expression step by step.
#+BEGIN_EXAMPLE
      #.db=23
0 0 0
0 0 0
0 0 0
0 0 0

0 0 0
0 1 1
0 1 1
0 0 0
      ,#.db=23
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0
#+END_EXAMPLE

next, this result is used to compress the indices of all elements in the
cube.
:    (,#.db=⍵)/⍳⍴,#.db
Let's have a look at the left side of the compression, this is the ravel
of the #.db, and then we take the shape of that (the length) and produce
all numbers from 1 to the length of the ravel; effectively producing
all array-indices of the raveled elements.

#+BEGIN_EXAMPLE
      ,#.db
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 23 23 0 23 23 0 0 0
      ⍴,#.db
24
      ⍳⍴,#.db
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
#+END_EXAMPLE

The compression of this with the binary array will select the indices
which have a 23 in the raveled array.

#+BEGIN_EXAMPLE
      (,#.db=23)/⍳⍴,#.db
17 18 20 21
#+END_EXAMPLE

Looking at the outermost expression, we now use these indices to assign values in #.db, 
but note that this actually happens on the raveled version of #.db!
:     (,#.db)[ 17 18 20 21 ]←0
If we execute this in the shell, and check #.db we will see that the cube has actually
been updated properly.

#+BEGIN_EXAMPLE
      #.db
0  0  0
0  0  0
0  0  0
0  0  0

0  0  0
0 23 23
0 23 23
0  0  0
      (,#.db)[ 17 18 20 21 ]←0
      #.db
0 0 0
0 0 0
0 0 0
0 0 0

0 0 0
0 0 0
0 0 0
0 0 0
#+END_EXAMPLE

** Human readable visualization
Not many users of a system (except ALP developers) would appreciate staring at
arrays and matrices. Let us now make this human readable by adding a show function
that displays the #.db in a nicer way. As a user, I would like to be able to write 
any of the following
:    show all
:    show monday tuesday 
:    show thursday
that is, I would like a show function that displays the room calendars for all days
or for an array of days or a single day. 
It helps when doing this to have some data, so I set up some bookings quickly.

#+BEGIN_EXAMPLE
      init_db ⍬
      init_bid
 ∇init_bid
      init_bid ⍬
      book first free on friday for 3 from 2
1
      book first free on friday for 4 from 1
2
      book first free on friday for 2 from 3
3
#+END_EXAMPLE

Let's start from the top, all should be an array of all week-day numbers.
This is done by editing the #.booking namespace (as usual) and just entering
:    all ← ⍳5
if we enter all in the Dyalog APL environment we get what we expect.
#+BEGIN_EXAMPLE
     all
1 2 3 4 5
#+END_EXAMPLE

next, the show function needs to accept an array of numbers and pretty-printing
the matrices for the days indicated by the array. Let us experiment and dry-run
this in the Dyalog APL environment. I will focus on pretty-printing one day
and then apply this for all days.

#+BEGIN_EXAMPLE
      { #.db[⍵;;] } 5
0 1 1 1 0 0 0 0
2 2 2 2 0 0 0 0
0 0 3 3 0 0 0 0
4 4 4 4 0 0 0 0
      { 0=#.db[⍵;;] } 5
1 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
1 1 0 0 1 1 1 1
0 0 0 0 1 1 1 1
      { '×⎕'[1+0=#.db[⍵;;]] } 5
⎕×××⎕⎕⎕⎕
××××⎕⎕⎕⎕
⎕⎕××⎕⎕⎕⎕
××××⎕⎕⎕⎕
      { ('mtwtf'[⍵]) ('×⎕'[1+0=#.db[⍵;;]]) } 5
f ⎕×××⎕⎕⎕⎕
  ××××⎕⎕⎕⎕
  ⎕⎕××⎕⎕⎕⎕
  ××××⎕⎕⎕⎕
      { ('mtwtf'[⍵]) ((⍳2⊃⍴#.db),'×⎕'[1+0=#.db[⍵;;]]) } 5
f 1 ⎕×××⎕⎕⎕⎕
  2 ××××⎕⎕⎕⎕
  3 ⎕⎕××⎕⎕⎕⎕
  4 ××××⎕⎕⎕⎕
#+END_EXAMPLE

This seems to fit the bill for a good day printout!
Let's call this show_day and put it in the #.booking namespace!

#+BEGIN_EXAMPLE
     ⎕vr 'show_day'
     ∇ show_day←{('mtwtf'[⍵])((⍳2⊃⍴#.db),'×⎕'[1+0=#.db[⍵;;]])}
     ∇
#+END_EXAMPLE

After saving, we can now try it out a bit.

#+BEGIN_EXAMPLE
      show_day 1
m 1 ⎕⎕⎕⎕⎕⎕⎕⎕
  2 ⎕⎕⎕⎕⎕⎕⎕⎕
  3 ⎕⎕⎕⎕⎕⎕⎕⎕
  4 ⎕⎕⎕⎕⎕⎕⎕⎕
      show_day 4
t 1 ⎕⎕⎕⎕⎕⎕⎕⎕
  2 ⎕⎕⎕⎕⎕⎕⎕⎕
  3 ⎕⎕⎕⎕⎕⎕⎕⎕
  4 ⎕⎕⎕⎕⎕⎕⎕⎕
      show_day ¨ ⍳5
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ××××⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕××⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ××××⎕⎕⎕⎕
#+END_EXAMPLE

however, we wanted one show function that also accept names, let's keep on it.
The show function should then automatically do the ¨ if necessary and we must
add support for the names of the days! Adding day name support is easy, we already
have friday, we just add the others (monday, tuesday, wednesday and thursday).

#+BEGIN_EXAMPLE
      monday tuesday wednesday thursday friday
1 2 3 4 5
      all
1 2 3 4 5
#+END_EXAMPLE

The day names can now be used as expected

#+BEGIN_EXAMPLE
      show_day monday
m 1 ⎕⎕⎕⎕⎕⎕⎕⎕
  2 ⎕⎕⎕⎕⎕⎕⎕⎕
  3 ⎕⎕⎕⎕⎕⎕⎕⎕
  4 ⎕⎕⎕⎕⎕⎕⎕⎕
      show_day friday
f 1 ⎕×××⎕⎕⎕⎕
  2 ××××⎕⎕⎕⎕
  3 ⎕⎕××⎕⎕⎕⎕
  4 ××××⎕⎕⎕⎕
#+END_EXAMPLE

however, the last adjustment is still to be made, the main function shall be 
named show and accept single days, or an array of days. As it turns out, this
is handled automatically!
Look at the following

#+BEGIN_EXAMPLE
     show_day ¨ monday
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕

     show_day ¨ monday wednesday friday
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ××××⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕××⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ××××⎕⎕⎕⎕
#+END_EXAMPLE

Therefore, the show function can now be defined as

:     ⎕vr 'show'
:     ∇ show←{show_day¨⍵}
:     ∇

and it works as expected

#+BEGIN_EXAMPLE
      show monday
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕

      show monday friday
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ××××⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕××⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ××××⎕⎕⎕⎕
#+END_EXAMPLE

** Demonstration
Thus, we can now book, and unbook! A short demonstration is in order of the full flow.
Starting of with db and bid initialization, then performing three different bookings.

#+BEGIN_EXAMPLE
      init_db ⍬
      init_bid ⍬
      book first free on monday for 4 from 2
1
      book first free on wednesday for 6 from 1
2
      book first free on friday for 5 from 2
3
      show all
 m 1 ⎕××××⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ××××××⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××××⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕
      book first free on friday for 3 from 2
4
      show friday
 f 1 ⎕×××××⎕⎕
   2 ⎕×××⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕
#+END_EXAMPLE

Next, we will do successive unbooks and show the results

#+BEGIN_EXAMPLE
     unbook with id 2
     show all
 m 1 ⎕××××⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××××⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕×××⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕

     unbook with id 4
     show all
 m 1 ⎕××××⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕×××××⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕

      unbook with id 3
      show all
 m 1 ⎕××××⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕⎕⎕⎕⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕

      unbook with id 1
      show all
 m 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   w 1 ⎕⎕⎕⎕⎕⎕⎕⎕   t 1 ⎕⎕⎕⎕⎕⎕⎕⎕   f 1 ⎕⎕⎕⎕⎕⎕⎕⎕
   2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕     2 ⎕⎕⎕⎕⎕⎕⎕⎕
   3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕     3 ⎕⎕⎕⎕⎕⎕⎕⎕
   4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕     4 ⎕⎕⎕⎕⎕⎕⎕⎕
#+END_EXAMPLE
** booking.dyalog code listing
If we now look at the booking.dyalog SALT script outside of the Dyalog APL environment,
it looks like this

#+BEGIN_EXAMPLE
:NameSpace booking

    init_db←{#.db←5 4 8 ⍴ 0}
    from←{⍺,(¯1+⍵)↓⍳8}
    for←{⍺,(⊃⍵)↑1↓⍵}
    on←{⍵}
    free←{ba←0=+/#.db[⊃⍵;;1↓⍵]
          r←ba/⍳2⊃⍴#.db
          (⊂r),⍵}
    first←{(⊃⊃⍵),1↓⍵}
    book←{bid←get_next_bid ⍬ ⋄#.db[2⊃⍵;1⊃⍵;2↓⍵]←bid⋄bid}

    init_bid←{ #.bid ← 1 }
    get_next_bid←{ r←#.bid⋄#.bid←1+r⋄r}
    id←{⍵}
    with←{⍵}
    unbook←{(,#.db)[(,#.db=⍵)/⍳⍴,#.db]←0}

    show←{ show_day ¨ ⍵ }
    all←⍳5
    show_day←{ ('mtwtf'[⍵]) ((⍳2⊃⍴#.db),'×⎕'[1+0=#.db[⍵;;]]) }
    monday←1
    tuesday←2
    wednesday←3
    thursday←4
    friday←5

:EndNameSpace
#+END_EXAMPLE

** Limitations and further work

As we have seen, it is very easy to write a DSL by using Dyalg APL,
however, this does not mean that the DSL which was easy to produce is
necessarily well designed. There are several things to consider, and 
one should not ignore these areas of concern without much afterthought.
This sub-chapter is a brief discussion on the design and development
of DSLs.

The DSL we developed was overly simplistic in that it was a mere vehicle
for your comprehension and the grammar is very rigid. It is also very hard
to extend as every function is extremely specific, and there is no underlying
data-model. Such a DSL as presented in this chapter is referred to as a
fully embedded DSL, it is defined and governed by functions in the underlying
language we are building it from.

We will revisit the DSL concept and implementation in a later chapter,
and follow through with a more structured approach in which we will think
of the data model, the grammar and the flexibility, before we get going.

Things to consider, what if we would like to be able to have more or fewer
conditions? What if I would like to be able to express the following?

#+BEGIN_EXAMPLE
   book first free before 1330 or after 1530 for 2 hours on monday or wednesday
#+END_EXAMPLE

Would it not make sense for the user to be able to type in the disjunct 
conditions in any order? For example this should also be possible to type

#+BEGIN_EXAMPLE
   book first free after 1530 or before 1330 for 2 hours on wednesday or monday
#+END_EXAMPLE

* Voting Analysis of Swedish Municipalities
We will now read a CSV (Comma Separated Values) file which I downloaded
from SCB (Statistiska Centralbyran; the swedish statistics bureau). 
It contains 2329 lines of data on 8 swedish parties and how different
swedish municipalities voted on these parties through the years 
1973,1976,1979,1982,1985,1988,1991,1994,1998,2002,2006,2010.


------------------------------------------------------------
TODO: Use KEY for this (⎕UCS 9016) ⌸ <------

** Create the SALT Script from within the Dyalog APL environment
In the Chapter 'A Tiny Booking DSL', we created the SALT script from outside
the Dyalog APL environment and then loaded it using =⎕SE.SALT.Load=.
We do not need to leave the environment at all, and can do the same thing
from within, let us look at how.

We start by creating the 'analysis' namespace by using the 'namespace' system
command =)ns= and supplying the name 'analysis'. We check that the namespace
is created by listing the namespaces afterwards, using =⎕NL 9=.

#+BEGIN_EXAMPLE
      )ns analysis
#.analysis

      ⎕NL 9
analysis
#+END_EXAMPLE

We can now save this (now empty) namespace into a Dyalog SALT script, by using
=⎕SE.SALT.Save= with the =-convert= option as follows (note that the option is given
as part of the same text array in which the target SALT script name is given).

#+BEGIN_EXAMPLE
      ⎕SE.SALT.Save #.analysis './analysis.dyalog -convert'
/home/gianfranco/APL/analysis.dyalog
#+END_EXAMPLE

If we now edit the =#.analysis= namespace in the Dyalog APL environment, we will
notice that it looks like a proper SALT script as follows.

#+BEGIN_EXAMPLE
    :NameSpace analysis
         ⎕IO ⎕ML ⎕WX ← 1 1 3

    :EndNameSpace 
#+END_EXAMPLE

The first line of Dyalog APL code 

:  ⎕IO ⎕ML ⎕WX ← 1 1 3

is actually no more special than an array strand notation assignment.
We can do this ourselves in the shell in the following way 

#+BEGIN_EXAMPLE
      a b c ← 1 (1 2 3) 2
      a
1
      b
1 2 3
      c
2
#+END_EXAMPLE

Let me take a brief moment and explain the most interesting system
property first =⎕IO=.

: ⎕IO 

'Quad IO' is the index origin, meaning, which will be the origin when indexing
and generating sequences. We can try changing it briefly and generating different
sequences with iota =⍳=.

#+BEGIN_EXAMPLE
      { ⎕IO←0 ⋄ ⍳ 5 } ⍬
0 1 2 3 4
      { ⎕IO←1 ⋄ ⍳ 5 } ⍬
1 2 3 4 5
#+END_EXAMPLE

We can also see the effect when indexing a text array, with the array 1 2 3.

#+BEGIN_EXAMPLE
      { ⎕IO←0 ⋄ 'quad-io'[ 1 2 3 ] } ⍬
uad
      { ⎕IO←1 ⋄ 'quad-io'[ 1 2 3 ] } ⍬
qua
#+END_EXAMPLE

APL developers can go to great lengths in religious battles regarding =⎕IO←1=
or =⎕IO←0=. However, the Dyalog APL standard is =⎕IO←1=.
=⎕ML= 'Quad ML' is the Migration Level of the Dyalog APL system. Ignore this completely
as it is no more than a historical remnant for backwards compatibility purposes
and shall have no meaning in your life whatsoever. This also goes for =⎕WX= 
'Quad WX', so please ignore =⎕ML= and =⎕WX=. The only reason for these System Variables
to be assigned is to make sure the SALT script will work and behave the same 
regardless of where we choose to fix it.

From now on, all functions will be added to the =#.analysis= namespace, so 
we can save our work in a proper version control system. 

But just to convince yourself that all is good, take a brief look at the
analysis.dyalog file outside of the Dyalog APL environment.

#+BEGIN_EXAMPLE
> cat analysis.dyalog
:Namespace analysis
⎕IO ⎕ML ⎕WX←1 1 3

:EndNamespace
#+END_EXAMPLE

** Opening a file for reading
The file we will work on is located in this course directory, it is called
ME0104B6.csv, let us start by 'tieing' the file.  Tieing the file creates
what can be thought of as a file descriptor, with which we can read from 
and write to the file, we use =⎕ntie= for tieing the file.

#+BEGIN_EXAMPLE
      tie←'./ME0104B6.csv' ⎕ntie 0
      tie
¯1
#+END_EXAMPLE

The =¯1= indicates that this is a so called 'native file', we know this
because all Native Files have negative tie numbers, and all Component Files
have positive tie numbers. Native files refer to non-Dyalog APL files, the 
other type of files (Component Files) are Dyalog APL specific and contain arrays,
they are sometimes also referred to as Arrays Stores. 
We can now query the size of the file we are tied to by utilizing the tie as
an input argument to the system function =⎕nsize=, this is the amount of bytes in the file.

#+BEGIN_EXAMPLE
      ⎕nsize tie
188962
#+END_EXAMPLE

contrast this with the size reported in the os when listing the file.

#+BEGIN_EXAMPLE
 > ls -l ME0104B6.csv
-rw-rw-r-- 1 gianfranco gianfranco 188962 Apr 15 21:55 ME0104B6.csv
#+END_EXAMPLE

Reading from this tie is done by using =⎕nread=, =⎕nread= supports
a very wide range of options, allowing you to perform very sophisticated
reads where the encoding is to be interpreted in multiple ways.
For the 'run of the mill' standard file reading, you want the
options as seen below. tie is the tie to the file, 80 is to read the
characters and interpret them as one byte per character, (⎕nsize tie)
indicates the size of the file we are tied to, and 0 is to start from 
offset 0. 

#+BEGIN_EXAMPLE
      contents←⎕NREAD tie 80(⎕NSIZE tie)0
      ⍴ contents
188962
#+END_EXAMPLE

Thus, we just read the whole content of the file, starting from offset 0,
and interpreting all bytes as single characters, and we put this into 
the variable contents, which now holds a text array of length 188962.
We can look at the first 50 characters of this text array.

#+BEGIN_EXAMPLE
     50 ↑ contents
region,parti mm,1973,1976,1979,1982,1985,1988,1991
#+END_EXAMPLE

we can also look at the last 50 characters of this text array, this is done
by using negative 50.

#+BEGIN_EXAMPLE
     ¯50 ↑ contents
mokraterna,..,..,..,..,..,..,..,..,20,75,334,827
#+END_EXAMPLE

We untie the tie with =⎕nuntie= as follows.

:    ⎕nuntie tie

As we are not so interested in the tie (the filedescriptor), but the contents
of the file, we put the tieing, reading and untieing into a function and just 
get the contents of the file.

We will now write our first User Defined Function, it will be called =read_file=
and accept the filepath as the right argument, it will be written inside the
analysis namespace (write #.analysis and press Ctrl-e to edit). As usual, I will
show what the result looks like when I am done, using vector representation =⎕vr=.

#+BEGIN_EXAMPLE
      ⎕vr '#.analysis.read_file'
     ∇ Z←read_file path;tie
[1]    tie←path ⎕NTIE 0
[2]    Z←⎕NREAD tie 80(⎕NSIZE tie)0
[3]    ⎕NUNTIE tie
     ∇
#+END_EXAMPLE

As this is the first time you see the User Defined Function format, I will 
mention some interesting aspects. All User Defined Functions start and end with a line
starting with 'del' (also known as carrot) =∇=. After this we show which variable
(if any) will hold the return value, in this case =Z= will be assigned the return value
of this function. Next on the same line as the first carrot, we have the function name,
which is =read_file=, after this follows the argument name (if any), which is =path=.
An optional variable declaration list comes after this, which is preceeded by semicolon
=;=.


----------------------------------------------------------------------
TODO: Tradfun (traditional function) not the first User Defined Function.
TODO: mention that variables that are not 'scoped' by the list of variables
      will become global and 'leak'.
TODO: Discuss tradfun vs dfuns <-- they where added as a functional extension
      to Dyalog APL.


#+BEGIN_EXAMPLE     
     Return variable declaration
       |      Function name
       |        |      Function argument
       |        |       |   Internal variable declaration
       ↓        ↓       ↓    ↓
     ∇ Z←  read_file  path ;tie
#+END_EXAMPLE

We check that the function is sound by invoking it with the path to the voting data.
And putting the result into content and inquiring the dimension of the text array by
using shape (rho) =⍴= (do not print it to the screen!).

#+BEGIN_EXAMPLE
      contents←#.analysis.read_file './ME0104B6.csv'
      ⍴contents
188962
      10↑contents
region,par
#+END_EXAMPLE

This seems to work well. The SALT script analysis.dyalog now contains the following
when we look at it from outside the Dyalog APL environment.

#+BEGIN_EXAMPLE
:Namespace analysis
    ⎕IO ⎕ML ⎕WX←1 1 3

    ∇ Z←read_file path;tie
      tie←path ⎕NTIE 0
      Z←⎕NREAD tie 80(⎕NSIZE tie)0
      ⎕NUNTIE tie
    ∇

:EndNamespace
#+END_EXAMPLE

** Parsing contents into lines
We can now move on to parsing this and doing something useful with the
contents. The interesting thing to realize now, is that the text array 
in content contains all characters, including the line feed character \n 
which has ASCII code 10. We can use the Unicode Convert function =⎕UCS= to 
recreate any character based on it's numeric code, and thus, we can match
all carriage returns with (⎕UCS 10), allowing us to count the amount of
newlines in the file.

--------------------------------------------------------------------
TODO: Reuse the split function from chapter 2 to use here and split.



#+BEGIN_EXAMPLE
      +/ contents = ⎕UCS 10
2329
#+END_EXAMPLE

notice that we plus-reduce the result from the comparison as we get a binary
array and wish to count the amount of ones. We can see this middle step
visually by performing the same comparison on the 20 first characters
from offset 70 in the text-array.

#+BEGIN_EXAMPLE
      contents[70+⍳20]=⎕UCS 10
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#+END_EXAMPLE

The 1 indicates a carriage return character matched at position 76, which we
can verify by indexing this element and using =⎕UCS= to display the ascii
code for it.

#+BEGIN_EXAMPLE
      ⎕UCS contents[76]
10
#+END_EXAMPLE

We can use what we have seen, together with 'partition' =⊂= from =⎕ML←3= to 
break the contents into lines, this is usually what you want to do when reading 
a file and parsing it.

#+BEGIN_EXAMPLE
      ⍴ { ⎕ML←3 ⋄ lines←(contents≠⎕UCS 10)⊂contents ⋄ lines } ⍬
2330
#+END_EXAMPLE

I will go through the code inside the direct function (inside the { }'s) briefly, 
line by line (remember that 'diamond' =⋄= is a line separator). 

:    ⎕ML←3  

This sets the Migration Level to 3. At Migration Level 3, we have access to the 
IBM definition of =⊂= called 'partition', which is very convenient for splitting
arrays.

:    lines←(contents≠⎕UCS 10)⊂contents

here we split the text array based on the binary array which is the result of 
finding all non-carriage returns. Every array element will now be text arrays
between the carriage returns - i.e the lines.

:    lines

This just returns the array of text-arrays. Note that I count the amount
of elements by using shape =⍴=. We might as well extract the second line
instead, by using 'pick' =⊃= with 2.

#+BEGIN_EXAMPLE
      2⊃ { ⎕ML←3 ⋄ lines←(contents≠⎕UCS 10)⊂contents ⋄ lines } ⍬

0114 Upplands Väsby,Moderaterna,1918,2678,3860,5197,4978,4364,5831,.....
#+END_EXAMPLE

Let us assign this result to lines and count them using shape ⍴.

#+BEGIN_EXAMPLE
      lines ← { ⎕ML←3 ⋄ lines←(contents≠⎕UCS 10)⊂contents ⋄ lines } ⍬
      ⍴lines
2330
#+END_EXAMPLE

As we now seem to have a direct function for parsing file contents into single
lines, we should save this into the =#.analysis= namespace with a proper name.
I propose to name the function =lines=. Just to make the direct function more
readable it will be a so called multilne direct function (a direct function 
across multiple lines).

#+BEGIN_EXAMPLE
      ⎕vr '#.analysis.lines'
     ∇ lines←{⎕ML←3
[1]        (⍵≠(⎕UCS 10))⊂⍵
[2]    }
     ∇
#+END_EXAMPLE

We can now try this again by verifying that we split into lines with the
function and rho =⍴=.

#+BEGIN_EXAMPLE
      ⍴#.analysis.lines contents
2330
#+END_EXAMPLE

The =#.analysis= namespace now contains

#+BEGIN_EXAMPLE
     :Namespace analysis
         ⎕IO ⎕ML ⎕WX←1 1 3

[0]      ∇ Z←read_file path;tie
[1]        tie←path ⎕NTIE 0
[2]        Z←⎕NREAD tie 80(⎕NSIZE tie)0
[3]        ⎕NUNTIE tie
[4]      ∇

[0]      lines←{⎕ML←3
[1]             (⍵≠(⎕UCS 10))⊂⍵
[2]      }

     :EndNamespace
#+END_EXAMPLE

** Parsing lines into table data

Next, we wish to parse one line, each line consisting of a municipality
code and the name of the municipality, followed by the swedish party name
and the amount of votes for this party during the different years.
We can thus split the input, but based on comma this time, using =⎕ML←3=.
I will turn on boxing which makes it easy to see the resulting arrays.

------------------------------------------------------------
TODO: Do not use ⎕ML 3 again!


#+BEGIN_EXAMPLE
      ]box on
Was OFF
#+END_EXAMPLE

An interesting detail to remember is that  setting =⎕ML←3= inside the direct function 
will ensure that the Migration Level is only changed within the execution environment
of thast direct function and not change outside the direct function.
We can see this with a small example on the Dyalog APL environment.

#+BEGIN_EXAMPLE
      ⎕ML
1
      { ⎕ML←3 ⋄ ⎕←'ML='⎕ML } ⍬
 ML=  3
      ⎕ML
1
#+END_EXAMPLE

The following example direct function pick's =⊃= the second array element from the lines and then 
splits the line on comma.

#+BEGIN_EXAMPLE
      {⎕ML←3⋄(⍵≠',')⊂⍵} 2⊃ #.analysis.lines contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
└──────────────────→┴──────────→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┘

      ⍴ {⎕ML←3⋄(⍵≠',')⊂⍵} 2⊃ #.analysis.lines contents
14
#+END_EXAMPLE

As we can see, we get a 14 element array from splitting a line into words, based on comma ','
as the separator. Let us now assign this direct function to =words= in the =#.analysis= namespace.

#+BEGIN_EXAMPLE
      ⎕vr '#.analysis.words'
      ∇ words←{⎕ML←3 ⋄ (⍵≠',')⊂⍵}
      ∇
#+END_EXAMPLE

And we should get the same result by applying the new function =words= on thes second line.

#+BEGIN_EXAMPLE
     #.analysis.words 2⊃ #.analysis.lines contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
└──────────────────→┴──────────→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┴───→┘
#+END_EXAMPLE


But this is not really enough, we need to convert vote amounts into integers from text
arrays which they are now. We can actually see how different things are represented
internally in Dyalog APL by using 'data representation' =⎕DR=, let us observe the results
for a floating points number, an integer, an integer array and an integer matrix.

------------------------------------------------------------
TODO: Describe that ⎕DR is to be interpreted as two digits.
      First is the amount of bits, and second is the type.


#+BEGIN_EXAMPLE
      0.1 1 (⍳4) (2 2⍴⍳4)
┌→──┬─┬───────┬───┐
│0.1│1│1 2 3 4│1 2│
│   │ │       │3 4↓
└~──┴─┴~─────→┴~─→┘

      ⎕DR ¨ 0.1 1 (⍳4) (2 2⍴⍳4)
645 83 83 83
#+END_EXAMPLE

likewise, let us look at the result of =⎕DR= on a single character, a text array and a 
text matrix.

#+BEGIN_EXAMPLE
      (⎕ucs 97) 'textarray' (2 5 ⍴ 'textmatrix')
┌→┬─────────┬─────┐
│a│textarray│textm│
│ │         │atrix↓
└─┴────────→┴────→┘

      ⎕DR ¨ (⎕ucs 97) 'textarray' (2 5 ⍴ 'textmatrix')
80 80 80
#+END_EXAMPLE

We can now check that we get what we expect when converting the result from =word= on a 
line. As we wish to explore our way into the correct result, we will try to find a solution
in the Dyalog APL environment before we encode it into the =#.analysis= namespace.

So, the first question is: How do we turn a text array into the number it represents?
The answer is luckily very simple, we use the built in monadic 'execute' =⍎= which interprets
the text array passed as the right argument as a Dyalog APL statement.
Observe the following examples

#+BEGIN_EXAMPLE
     ⍎ '10'
10
     ⍎ '⍳10'
1 2 3 4 5 6 7 8 9 10

     ⍎ '2 5 ⍴ ⍳10'
1 2 3 4  5
6 7 8 9 10
#+END_EXAMPLE

We can see that the data representation =⎕DR= of the result is coherent with what
we have seen before for integers, arrays and matrices.

#+BEGIN_EXAMPLE
     ⎕dr ⍎ '10'
83
     ⎕dr ⍎ '⍳10'
83
     ⎕dr ⍎ '2 5 ⍴ ⍳10'
83
#+END_EXAMPLE

Back to the task at hand armed with execute =⍎=, we wish to execute all but the first
two elements of the line. So, what if we take the first two elements, and catenate this
with the result of executing every element of the remaining array?
Let us also contrast this against a listing of the types of the original untouched elements
we get from applying =words=.

#+BEGIN_EXAMPLE
     {⍵,[0.5]⎕dr ¨⍵} #.analysis.words 2⊃ #.analysis.lines contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
├──────────────────→┼──────────→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┼───→┤
│80                 │80         │80  │80  │80  │80  │80  │80  │80  │80  │80  │80  │80  │80  │
└~──────────────────┴~──────────┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

Okay, so taking the first 2 elements, we can do that with dyadic 'take' =↑=, then we also 
need to  drop the first two, which can be done with dyadic 'drop' =↓=, and then we execute
the rest with =⍎=.

#+BEGIN_EXAMPLE
     {⍵,[0.5]⎕dr ¨⍵} {(2↑⍵),(⍎¨2↓⍵)}  #.analysis.words 2⊃ #.analysis.lines contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
├──────────────────→┼──────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│80                 │80         │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │
└~──────────────────┴~──────────┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

The code 163 stands for '16 bit signed integer' if you read the =⎕DR= manual pages for Dyalog APL.
Therefore, the added direct function ={(2↑⍵),(⍎¨2↓⍵)}= is most likely correct.
Let us store it into the =#.analysis= namespace as 'parse'.

#+BEGIN_EXAMPLE
     ⎕vr '#.analysis.parse'
     ∇ parse←{(2↑⍵),(⍎¨2↓⍵)}
     ∇
#+END_EXAMPLE

A sanity check that this works as expected is never wrong

#+BEGIN_EXAMPLE
     {⍵,[0.5]⎕dr ¨⍵} #.analysis.parse #.analysis.words 2⊃ #.analysis.lines contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
├──────────────────→┼──────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│80                 │80         │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │163 │
└~──────────────────┴~──────────┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE
 
The only thing we are missing now, is a way to put all of this into a table. We know that
each line can be parsed properly into an array, so what remains is to take an array of
arrays and turn this into a matrix. The function for that is called monadic 'mix' =↑=.
Let us look at what it does with a small example.

#+BEGIN_EXAMPLE
     ⍴ (1 2 3) (4 5 6) (7 8 9)
3
     ⍴ ↑ (1 2 3) (4 5 6) (7 8 9)
3 3
     ↑ (1 2 3) (4 5 6) (7 8 9)
1 2 3
4 5 6
7 8 9
#+END_EXAMPLE

Likewise, we should be able to mix =↑= the result of word-splitting and parsing each
line. The combined word-split and parsing can be done with function composition using
'jot' =∘=. Let me first change the current namespace since I am getting very tired of
typing the same namespace name over and over again.

#+BEGIN_EXAMPLE
      ⎕cs '#.analysis'
      ⎕this
#.analysis
#+END_EXAMPLE

Remember that 'change space' =⎕cs=  used to change the current namespace, and that
=⎕this= is used to retrieve the name of the current namespace. When in the =#.analysis=
namespace, we can access the functions immediately without having to prefix them with 
the names.

#+BEGIN_EXAMPLE
     parse∘words 2⊃ lines #.contents
┌→──────────────────┬───────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│                   │Moderaterna│1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
│0114 Upplands Väsby│           │    │    │    │    │    │    │    │    │    │    │    │    │
└──────────────────→┴──────────→┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

We would next want to perform =parse∘words= on every result from lines of #.contents.
Why did I change =contents= to =#.contents= all of a sudden? Well, because we moved
into the =#.analysis= namespace, from the root namespace =#=, and the =contents= variable
was created in the root namespace =#=.
What we would like to do is the following

:      ⍴ ↑ parse∘words ¨ lines #.contents

But, doing this exposes an error (or as I like so say; an interesting situation).


------------------------------------------------------------
TODO: Switch to ⎕VFI (Verify and Fix input) 
TODO: Explain the vulnerability issues with ⍎ in general.


#+BEGIN_EXAMPLE
     ⍴ ↑ parse∘words ¨ lines #.contents
⍎SYNTAX ERROR
parse[0] ..
#+END_EXAMPLE

The way to interpet this error, is that execute =⍎= hit a syntax error when trying to execute
the passed text array containing =..=, in the function parse, on line zero (0). 
Because we have the ability to quickly look at the source of a
direct function via vector representation =⎕vr=, we do so.

:      ⎕vr 'parse'
:      ∇ parse←{(2↑⍵),(⍎¨2↓⍵)}
:      ∇


Right, so we see =..= somewhere in the number series then. A quick grep in the linux
environment for ',..' should give us a hint of what this looks like.

#+BEGIN_EXAMPLE
> grep ',\.\.' ME0104B6.csv | more
0126 Huddinge,Sverigedemokraterna,..,..,..,..,..,..,..,..,368,764,1297,2569
0127 Botkyrka,Kristdemokraterna,232,242,282,398,..,592,1793,1072,3243,3327,2537,2110
#+END_EXAMPLE

All right, so when there is no data for a specific party during a specific year, the
result is '..' instead of zero. In our case, it would be better if these '..' where to
be encoded as zeroes. So, what we want to, is to convert =..= into zero, or execute
whatever it is; this merits its own name, something like =parse_votes=.
But first, I will introduce you to direct function guards.

Guards are expressions wich allow you to control the flow of the execution within 
the direct function, they are expressed as boolean expressions ending with a colon ':'.
Some simple examples will elucidate this for you.

First a simple guard testing if the right argument is 1.
#+BEGIN_EXAMPLE
      { ⍵=1:'equal to one' ⋄ 'not equal to one'} ¨ 1 0 0 1
┌→───────────┬────────────────┬────────────────┬────────────┐
│equal to one│not equal to one│not equal to one│equal to one│
└───────────→┴───────────────→┴───────────────→┴───────────→┘
#+END_EXAMPLE

Now with two guards, the first guard is a compound expression with the connective 'and' ∧,

and the second guard tests for membership in an array.

:      { (⍵≤4) ∧ (⍵ ≥ 1):'1-4' ⋄ ⍵∊(5 6 7 8):'5-8' ⋄ ⍵ } ¨ ¯2+⍳12
: ┌→─┬─┬───┬───┬───┬───┬───┬───┬───┬───┬─┬──┐
: │¯1│0│1-4│1-4│1-4│1-4│5-8│5-8│5-8│5-8│9│10│
: └~─┴─┴──→┴──→┴──→┴──→┴──→┴──→┴──→┴──→┴─┴~─┘

The final example shows that a guard can access a variable which has been assigned
to in the beginning of the direct function.

#+BEGIN_EXAMPLE
      { (f s)←⍵ ⋄ f>s:'first!' ⋄ f<s:'second!' ⋄ 'equal!' } ¨ (1 2) (2 1) (1 1)
┌→──────┬──────┬──────┐
│second!│first!│equal!│
└──────→┴─────→┴─────→┘
#+END_EXAMPLE

Let us now use the guard to test the possible number for equality with =..= and
if so, return it as zero (0). Otherwise we execute it.

#+BEGIN_EXAMPLE
       { ⍵≡'..': 0 ⋄ ⍎ ⍵ } '12'
12
       { ⍵≡'..': 0 ⋄ ⍎ ⍵ } '..'
0
#+END_EXAMPLE

Let us put this as =parse_votes= in our =#.analysis= namespace, and change so that
the parse function uses =parse_votes= on each of the possible votes instead of just
execute =⍎=.

#+BEGIN_EXAMPLE
     ⎕vr 'parse_votes'
     ∇ parse_votes←{⍵≡'..':0 ⋄ ⍎⍵}
     ∇
     
     ⎕vr 'parse'
     ∇ parse←{(2↑⍵),(parse_votes¨2↓⍵)}
     ∇
#+END_EXAMPLE

We can now try to re-run the same function that failed before 

#+BEGIN_EXAMPLE
      ⍴ parse∘words ¨ lines #.contents
2329
#+END_EXAMPLE

Voila, we get 2329 results, each array of the 2329 arrays is an internal 
data array of length 14.

#+BEGIN_EXAMPLE
      ⍴ 2 ⊃ parse∘words ¨ lines #.contents
14
#+END_EXAMPLE

We can thus mix this result into a 2329 by 14 matrix and assign this to a
variable which we call =tab= for table.

#+BEGIN_EXAMPLE
      ⍴ ↑ parse∘words ¨ lines #.contents
2329 14

      tab ← ↑ parse∘words ¨ lines #.contents
      tab[2 3 4;]
┌→──────────────────┬─────────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓0114 Upplands Väsby│Moderaterna  │1918│2678│3860│5197│4978│4364│5831│5782│5901│3822│7326│8397│
├──────────────────→┼────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│0114 Upplands Väsby│Centerpartiet│2917│3141│2108│1723│964 │1071│660 │586 │439 │489 │848 │918 │
├──────────────────→┼────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│0114 Upplands Väsby│Folkpartiet  │1201│2151│1989│978 │3206│3098│2550│1833│1028│3350│1907│1890│
└──────────────────→┴────────────→┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

We thus define the last direct function for parsing this to a table 
in the =#.analysis= namespace.

#+BEGIN_EXAMPLE
     ⎕vr 'to_table'
     ∇ to_table←{ ↑ parse∘words¨lines ⍵}
     ∇
#+END_EXAMPLE

and the final check that this is working as expected (2329 rows and 14 columns)

#+BEGIN_EXAMPLE
      ⍴ to_table read_file './ME0104B6.csv'
2329 14
#+END_EXAMPLE


------------------------------------------------------------
TODO: Do I really need to ⎕vr all the functions or just enough
      to show the definition?

** Analysis of table data

------------------------------------------------------------
TODO: ⍳ ≢ and not ⍳⊃⍴ 


We now have a reliable and fast way of parsing the voting data into a
table, which will allow us to perform queries and analyze the vote
results. Let us work with this and start answering some questions.

:    table← to_table read_file './ME0104B6.csv'

As we can see quickly (and will see in the different parts to come,
the first row is unfortunately the header of the columns and thus never
interesting for all the statistics, unless we have forgotten what the
columns represent. Let us drop the first row and reassign to the table.

:   table ← 1↓table

*** Which parties are part of the statistics?

We can collect the whole second column or all rows and take the set
union on this and mix the result to produce a readable text matrix.

#+BEGIN_EXAMPLE
      ↑ ∪ table[;2]
Moderaterna
Centerpartiet
Folkpartiet
Kristdemokraterna
Miljöpartiet
Socialdemokraterna
Vänsterpartiet
Sverigedemokraterna
#+END_EXAMPLE

*** How do we target one specific municipality?

I grew up in a small municipality called Svalöv, we can find all rows which 
has Svalöv data by utilizig replicate =/= and substring match of the text
'Svalöv'. For this we will use the dyadic function 'find' (underscore
epsilon)  =⍷= which returns a binary array indicating where the occurrences
are in the right argument of the left argument.
See the following example below

#+BEGIN_EXAMPLE
     'tea' ⍷ 'teatralictea'
1 0 0 0 0 0 0 0 0 1 0 0
#+END_EXAMPLE

With find =⍷= we will be able to generate the indices of the rows for
which the first column contains 'Svalöv'. I will first present the
expression and then break it down for you.

#+BEGIN_EXAMPLE
       ({ ∨/ 'Svalöv' ⍷ ⍵ } ¨ table[;1])/⍳⊃⍴table
761 762 763 764 765 766 767 768
#+END_EXAMPLE

At the right side of replicate =/= we have 

:   ⍳⊃⍴table 

(the indices of each row). This is done by using shape =⍴= which 
returns the dimensions of the table, then selecting the first 
number of that array (with pick ⊃) and then generating all numbers 
from 1 to that number.

On the left side of replicate =/= we have 

:   ({ ∨/ 'Svalöv' ⍷ ⍵ } ¨ table[;1])

(match rows containing 'Svalöv'). This is done by selecting all the
first columns from all rows in table, and then, for each element,
performing an each with a direct function in which we search for
'Svalöv' and do an or-reduction on the resulting binary array.
The or reduction is necessary to produce a single binary value
for each find result against each row.

Replicate works both like a function for removing elements from
arrays, and as a function to duplicate elements. Look at the 
following examples

#+BEGIN_EXAMPLE
     0 1 1 0 1 0 0 0 0 / 'teatralic'
ear

      1 2 3 4 / 'abcd'
abbcccdddd

      (⌽⍳5)/⍳5
1 1 1 1 1 2 2 2 2 3 3 3 4 4 5
#+END_EXAMPLE

back to the original expression which returns the row indices
for which 'Svalöv' is part of the name, we can take these row
indices and select all columns with it.

#+BEGIN_EXAMPLE
      rows ←  ({ ∨/ 'Svalöv' ⍷ ⍵ } ¨ table[;1])/⍳⊃⍴table
      rows
761 762 763 764 765 766 767 768
      table[rows;]
┌→──────────┬───────────────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓1214 Svalöv│Moderaterna        │884 │1114│1586│1889│1768│1473│1678│1748│1670│1103│1713│2167│
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Centerpartiet      │3112│3066│2286│2089│1762│1538│1219│1177│932 │919 │1030│924 │
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Folkpartiet        │422 │607 │690 │341 │779 │622 │480 │296 │228 │696 │444 │454 │
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Kristdemokraterna  │55  │64  │42  │64  │0   │137 │481 │201 │704 │526 │321 │272 │
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Miljöpartiet       │0   │0   │0   │66  │93  │386 │186 │321 │214 │206 │228 │380 │
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Socialdemokraterna │3412│3422│3501│3727│3631│3407│2955│3764│2848│2969│2672│2284│
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Vänsterpartiet     │119 │105 │109 │122 │115 │163 │134 │209 │471 │297 │225 │274 │
├──────────→┼──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│1214 Svalöv│Sverigedemokraterna│0   │0   │0   │0   │0   │0   │0   │0   │35  │355 │729 │1039│
└──────────→┴──────────────────→┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

Now we know these are all from Svalöv, so we can drop the first column and only focus on the
parties and their votes, this is done with dyadic drop along the second dimension.

#+BEGIN_EXAMPLE
      1↓[2] table[rows;]
┌→──────────────────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
↓Moderaterna        │884 │1114│1586│1889│1768│1473│1678│1748│1670│1103│1713│2167│
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Centerpartiet      │3112│3066│2286│2089│1762│1538│1219│1177│932 │919 │1030│924 │
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Folkpartiet        │422 │607 │690 │341 │779 │622 │480 │296 │228 │696 │444 │454 │
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Kristdemokraterna  │55  │64  │42  │64  │0   │137 │481 │201 │704 │526 │321 │272 │
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Miljöpartiet       │0   │0   │0   │66  │93  │386 │186 │321 │214 │206 │228 │380 │
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Socialdemokraterna │3412│3422│3501│3727│3631│3407│2955│3764│2848│2969│2672│2284│
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Vänsterpartiet     │119 │105 │109 │122 │115 │163 │134 │209 │471 │297 │225 │274 │
├──────────────────→┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┼~───┤
│Sverigedemokraterna│0   │0   │0   │0   │0   │0   │0   │0   │35  │355 │729 │1039│
└──────────────────→┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┴~───┘
#+END_EXAMPLE

*** Which are the most popular parties in Svalöv?

One way of knowing this is to rank the parties every year, and display 
the ranked list. Let's start by assining the current result to votes

:    votes ← 1↓[2] table[rows;]

Next we calculate the percentage of the votes for every party as they
are in the first column, by summing the total votes and doing division
with the sum; let us start with the first year (1973).


------------------------------------------------------------
TODO: Calculating the percentage will not change the order between 
      the votes.
TODO: All divide by votes are unnecessary.


#+BEGIN_EXAMPLE
      votes[;2]
884 3112 422 55 0 3412 119 0

      +/votes[;2]
8004

      votes[;2]÷+/votes[;2]
0.1104447776 0.3888055972 0.05272363818 0.006871564218 0 0.4262868566 0.01486756622 0
#+END_EXAMPLE

Next, we wish to see the indices of the sorted result, in descending order, remember
that we use grade down for that =⍒=.

#+BEGIN_EXAMPLE
      ⍒ votes[;2]÷+/votes[;2]
6 2 1 3 7 4 5 8
#+END_EXAMPLE

If we now want the names in this order, we index the first column for all rows
with these indices, and do mix =↑= to get a nice readable table.

#+BEGIN_EXAMPLE
      ↑votes[;1][⍒ votes[;2]÷+/votes[;2]]
Socialdemokraterna
Centerpartiet
Moderaterna
Folkpartiet
Vänsterpartiet
Kristdemokraterna
Miljöpartiet
Sverigedemokraterna
#+END_EXAMPLE

Next, let us do this for each year, that means, all the remaining columns 3..13 in votes.
We can do this with each =¨= and a direct function.

#+BEGIN_EXAMPLE
      { ↑votes[;1][⍒ votes[;⍵]÷+/votes[;⍵]] } ¨ 2+⍳11
#+END_EXAMPLE

This result will crowd the screen, and perhaps we really only care for the top 3 parties,
which we do by take:ing =↑= the first 3 indices from grade down.
If we shape =⍴= this result into a 3 by 4 matrix, we will be able to read it easier,
but beware! The last element of the matrix (bottom right corner) will be a duplicate of
the first element! 

#+BEGIN_EXAMPLE
     3 4 ⍴ { ↑votes[;1][ 3 ↑ ⍒ votes[;⍵]÷+/votes[;⍵]] } ¨ 2+⍳11
┌→─────────────────┬──────────────────┬───────────────────┬──────────────────┐
↓Socialdemokraterna│Socialdemokraterna│Socialdemokraterna │Socialdemokraterna│
│Centerpartiet     │Centerpartiet     │Centerpartiet      │Moderaterna       │
│Moderaterna       ↓Moderaterna       ↓Moderaterna        ↓Centerpartiet     ↓
├─────────────────→┼─────────────────→┼──────────────────→┼─────────────────→┤
│Socialdemokraterna│Socialdemokraterna│Socialdemokraterna │Socialdemokraterna│
│Centerpartiet     │Moderaterna       │Moderaterna        │Moderaterna       │
│Moderaterna       ↓Centerpartiet     ↓Centerpartiet      ↓Centerpartiet     ↓
├─────────────────→┼─────────────────→┼──────────────────→┼─────────────────→┤
│Socialdemokraterna│Socialdemokraterna│Socialdemokraterna │Socialdemokraterna│
│Moderaterna       │Moderaterna       │Moderaterna        │Centerpartiet     │
│Centerpartiet     ↓Centerpartiet     ↓Sverigedemokraterna↓Moderaterna       ↓
└─────────────────→┴─────────────────→┴──────────────────→┴─────────────────→┘
#+END_EXAMPLE

This is because the matrix is larger than the amount of elements,
and the first element in the passed array will be used to fill the first large slot,
and so on. Observe the following.

#+BEGIN_EXAMPLE
      ⍳ 7
1 2 3 4 5 6 7

      2 4 ⍴ ⍳ 7
1 2 3 4
5 6 7 1

      3 4 ⍴ ⍳ 7
1 2 3 4
5 6 7 1
2 3 4 5
#+END_EXAMPLE

We can however answer the question, and say with certainty that in Svalöv, the 
most popular parties are =Socialdemokraterna=, =Moderaterna= and =Centerpartiet=.











